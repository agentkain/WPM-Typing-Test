<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WPM Typing Speed Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚å®Ô∏è</text></svg>">
    <style>

        /* 
        Proprietary License

        Copyright (c) 2024 Chi Alexander

        This software is provided 'as-is,' without any express or implied
        warranty. In no event will the authors be held liable for any damages
        arising from the use of this software.

        Redistribution and use in source and binary forms, with or without
        modification, are not permitted without the explicit permission
        from the copyright holder.
        */

        :root {
    --beginner-color: #2ecc71;
    --intermediate-color: #3498db;
    --advanced-color: #9b59b6;
    --all-levels-color: #34495e;
    --beginner-text-color: #ffffff;
    --intermediate-text-color: #ffffff;
    --advanced-text-color: #ffffff;
    --all-levels-text-color: #ffffff;
    --reset-button-color: #d00002;
    --reset-button-text-color: #ffffff;
    --beginner-cursor-color: #2ecc71;
    --intermediate-cursor-color: #3498db;
    --advanced-cursor-color: #9b59b6;


}



#input:focus {
    outline: none;
    border-color: var(--highlight-color);
}

#input.border-beginner:focus {
    border-color: var(--beginner-color);
}

#input.border-intermediate:focus {
    border-color: var(--intermediate-color);
}

#input.border-advanced:focus {
    border-color: var(--advanced-color);
}

/* Ensure the default styles are also covered */
#input.border-beginner {
    border-color: var(--beginner-color);
}

#input.border-intermediate {
    border-color: var(--intermediate-color);
}

#input.border-advanced {
    border-color: var(--advanced-color);
}






.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 34px;
}



input:checked + .slider {
    background-color: #9a9a9a;
}

input:checked + .slider:before {
    transform: translateX(26px);
}


input:checked + .slider:before {
  transform: translateX(26px);
  content: "üåô"; /* Add the crescent moon emoji */
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  filter: grayscale(100%); /* Apply grayscale effect */
}

/* Optionally, add a different color for the unchecked state */
input:not(:checked) + .slider:before {
  content: "‚òº"; /* Add the sun emoji */
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #7e7e7e,
  
  
}

input:not(:checked) + .slider {
  background-color: #eeeeee; /* Change this to your desired color */
}

        #share-results-button {
            padding: 10px 20px;
            background-color: #0cb431; /* Change this to your desired background color */
            color: white; /* Change this to your desired text color */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        #share-results-button:hover {
            background-color: #098323; /* Change this to your desired hover color */
        }

        /* Add these styles to your existing CSS */
        .view-progress-button {
            flex: 1;
            padding: 10px;
            background-color: #34495E; /* Change this to your desired color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .close-results-button {
            flex: 1;
            padding: 10px;
            background-color: #d9534f; /* Change this to your desired color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        
        


        body.dark-mode {
            --beginner-color: #27ae60;
            --intermediate-color: #2980b9;
            --advanced-color: #8e44ad;
            --all-levels-color: #2c3e50;
            --reset-button-color: #d00002; /* Keep the same red color in dark mode */
            --reset-button-text-color: #ffffff;
        }

        #reset-progress {
            background-color: var(--reset-button-color);
            color: var(--reset-button-text-color);
        }

        body {
            font-family: 'Figtree', sans-serif;
            line-height: 1.2;
            color: #333;
            max-width: 870px;
            margin: 0 auto;
            padding: 20px;
        }

        h1, h2 {
            text-align: center;
            color: #2c3e50;
        }

        body.dark-mode h1,
        body.dark-mode h2,
        body.dark-mode h3,
        body.dark-mode h4,
        body.dark-mode h5,
        body.dark-mode h6 {
            color: #ffffff;
        }

        body.dark-mode .modal-content h2 {
            color: #ffffff;
        }

        #typing-area {
            background-color: #f1f1f1;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            font-size: 24px;
            min-height: 50px;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            transition: border-color 0.3s ease;
        }

        @media (max-width: 600px) {
            #typing-area {
                font-size: 18px;
            }
        }

    

        

        #input.border-beginner { border-color: var(--beginner-color); }
        #input.border-intermediate { border-color: var(--intermediate-color); }
        #input.border-advanced { border-color: var(--advanced-color); }

        body.dark-mode #input {
            border-color: #555555; /* Default dark mode border color */
        }

        body.dark-mode #input.border-beginner { border-color: var(--beginner-color); }
        body.dark-mode #input.border-intermediate { border-color: var(--intermediate-color); }
        body.dark-mode #input.border-advanced { border-color: var(--advanced-color); }



        .input-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            margin-bottom: 1px;
            
        }

        .stats-group, .button-group, #stats, #difficulty-filter {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            overflow: hidden;
            border-radius: 5px;
            height: auto;
        }

        

        
       


      
            .current-word.incorrect {
                background-color: #ffcccc;
                color: #ff0000;
                text-shadow: none;
            }

        .current-word {
            background-color: var(--highlight-color, #34495e);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            text-shadow: 0px 0px 3px rgba(0,0,0,0.5);
        }

        .stats-item, .stat {
            flex: 1 1 200px;
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            margin: 5px;
        }

            .stats-item strong, .stat h3 {
                margin-bottom: 5px;
                font-size: 20px;
            }

        button {
            padding: 10px 20px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

       

            .current-word.incorrect {
                background-color: #ffcccc;
                color: #ff0000;
            }

        #beginner-btn {
            background-color: #2ecc71;
        }

        #intermediate-btn {
            background-color: #3498db;
        }

        #advanced-btn {
            background-color: #9b59b6;
        }

        #custom-text-btn, #view-progress-button, #reset-progress {
            width: 48%;
            height: 50px;
        }

        #start-button {
            width: 98%;
            padding: 10px;
            background-color: #dddddd;
            color: #666666;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 0 auto 20px auto;
            display: block;
        }


            #start-button:disabled {
                cursor: not-allowed;
                opacity: 0.7;
            }

        #view-progress-button {
            background-color: #34495e;
        }

        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        #font-size-selector {
            margin-bottom: 10px;
        }

        


        .up {
            color: green;
        }

        .down {
            color: red;
        }

        #progress-chart {
            margin-top: 20px;
        }

        #disclaimer {
            margin-top: 20px;
            font-size: 0.9em;
            color: #7f8c8d;
            text-align: center;
        }

        

        @media (max-width: 600px) {
            .modal-content {
                width: 95%;
                margin: 2% auto;
            }
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 20px;
            flex-direction: row;
        }

            .modal-buttons button {
                flex: 1; /* Make buttons take equal space */
                padding: 10px 20px; /* Adjust padding for desired button size */
                font-size: 14px; /* Adjust font size */
                height: 50px; /* Ensure both buttons have the same height */
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            .modal-buttons .close-button {
                background-color: #34495e;
                color: white;
            }

            .modal-buttons #reset-progress {
                background-color: #d00002;
                color: white;
            }

            .modal-buttons button:hover {
                opacity: 0.9;
            }

            body.dark-mode {
                --reset-button-color: #d00002;
                --reset-button-text-color: #ffffff;
            }



        #difficulty-filter {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 20px;
        }

            #difficulty-filter button {
                flex: 1;
                padding: 10px;
                font-size: 16px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s, transform 0.1s;
                color: white;
            }

                #difficulty-filter button:hover {
                    opacity: 0.9;
                    transform: scale(1.05);
                }

        #beginner-filter-btn {
            background-color: #2ecc71;
        }

        #intermediate-filter-btn {
            background-color: #3498db;
        }

        #advanced-filter-btn {
            background-color: #9b59b6;
        }

        

        #difficulty-filter button.selected {
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        

        #start-button {
            position: relative;
        }

            #start-button:hover::after {
                content: attr(title);
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                padding: 5px;
                background-color: #333;
                color: white;
                border-radius: 4px;
                white-space: nowrap;
                font-size: 14px;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s;
            }

            #start-button:hover:not(:disabled)::after {
                opacity: 1;
            }

        .button-group {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
        }

            .button-group button {
                flex-grow: 1;
                margin: 0 5px;
                padding: 10px 20px;
                font-size: 16px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

                .button-group button:first-child {
                    margin-left: 0;
                }

                .button-group button:last-child {
                    margin-right: 0;
                }

        #beginner-btn {
            background-color: #2ecc71;
        }

        #intermediate-btn {
            background-color: #3498db;
        }

        #advanced-btn {
            background-color: #9b59b6;
        }

        .button-group button:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        #stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

            .stat h3 {
                margin-top: 0;
                font-size: 14px;
            }

            .stat p {
                margin-bottom: 0;
                font-size: 18px;
                font-weight: bold;
            }

        body.dark-mode {
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        .dark-mode #typing-area {
            background-color: #2c2c2c;
            color: #f0f0f0;
        }

        .dark-mode #input {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border-color: #555;
        }

        

        .dark-mode .stats-item, .dark-mode .stat {
            background-color: #2c2c2c;
            color: #f0f0f0;
        }

        .dark-mode .modal-content {
            background-color: #2c2c2c;
            color: #f0f0f0;
        }

        .dark-mode button {
            background-color: #444444;
            color: #ffffff;
        }

            .dark-mode button:hover {
                background-color: #555555;
            }

        
        .dark-mode input, .dark-mode select {
            background-color: #333333;
            color: #ffffff;
            border-color: #555555;
        }

        .dark-mode #start-button {
            background-color: #444444;
            color: #ffffff;
        }

        .dark-mode #view-progress-button {
            background-color: #34495e;
        }

        /* Update these rules in your existing CSS */

        .dark-mode #beginner-btn, .dark-mode #beginner-filter-btn {
            background-color: #27ae60; /* Slightly darker shade of green */
            color: #2ecc71;
        }

        .dark-mode #intermediate-btn, .dark-mode #intermediate-filter-btn {
            background-color: #2980b9; /* Slightly darker shade of blue */
            color: #2980b9;
        }

        .dark-mode #advanced-btn, .dark-mode #advanced-filter-btn {
            background-color: #8e44ad; /* Slightly darker shade of purple */
            color: #8e44ad;
        }

        .dark-mode #all-levels-btn {
            background-color: #2c3e50; /* Darker shade of blue-grey */
            color: #2c3e50;
        }

        /* Ensure other buttons in dark mode have a consistent style */
        .dark-mode button:not(#beginner-btn):not(#intermediate-btn):not(#advanced-btn):not(#all-levels-btn):not(#beginner-filter-btn):not(#intermediate-filter-btn):not(#advanced-filter-btn):not(#dark-mode-toggle) {
            background-color: #333;
            color: #ffffff;
        }

        .dark-mode button:hover {
            opacity: 0.9;
        }

        /* Specific styles for start and view progress buttons */
        .dark-mode #start-button {
            background-color: var(--highlight-color, #444444);
            color: #ffffff;
        }

        .dark-mode #view-progress-button {
            background-color: #34495e;
            color: #ffffff;
        }


        body.dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --secondary-bg: #2c2c2c;
            --secondary-text: #cccccc;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #resetModal .modal-buttons button {
            padding: 10px 20px;
            font-size: 14px;
            height: 50px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #resetModal .modal-buttons button:first-child {
            background-color: #d00002; /* Color for "Yes, Reset" button */
            color: white;
        }

        #resetModal .modal-buttons button:last-child {
            background-color: #34495e; /* Color for "Cancel" button */
            color: white;
            }

        #resetModal .modal-buttons button:hover {
            opacity: 0.9;
        }

        #progress-chart-container {
            width: 100%;
            height: 23vh; /* Adjust this value as needed */
            margin-bottom: 5px;
        }

        

        /* CSS for the border colors */
        .border-beginner {
            border: 2px solid var(--beginner-color);
        }

        .border-intermediate {
            border: 2px solid var(--intermediate-color);
        }

        .border-advanced {
            border: 2px solid var(--advanced-color);
        }

        /* Ensure other buttons in dark mode have a consistent style */
        body.dark-mode button:not(#reset-progress) {
            background-color: #444444;
            color: #ffffff;
        }

        body.dark-mode #resetModal .modal-buttons button:first-child {
            background-color: var(--reset-button-color);
            color: var(--reset-button-text-color);
        }

        .border-beginner {
            border: 2px solid var(--beginner-color);
        }

        .border-intermediate {
            border: 2px solid var(--intermediate-color);
        }

        .border-advanced {
            border: 2px solid var(--advanced-color);
        }

        #share-results-button {
            padding: 10px 20px;
            background-color: transparent;
            border: 2px solid;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #share-results-button.beginner {
            color: var(--beginner-color) !important;
            border-color: var(--beginner-color);
        }

        #share-results-button.intermediate {
            color: var(--intermediate-color) !important;
            border-color: var(--intermediate-color);
        }

        #share-results-button.advanced {
            color: var(--advanced-color) !important;
            border-color: var(--advanced-color);
        }

        #share-results-button.beginner:hover {
            background-color: var(--beginner-color);
            color: var(--beginner-text-color) !important;
        }

        #share-results-button.intermediate:hover {
            background-color: var(--intermediate-color);
            color: var(--intermediate-text-color) !important;
        }

        #share-results-button.advanced:hover {
            background-color: var(--advanced-color);
            color: var(--advanced-text-color) !important;
        }

        /* Dark mode styles */
        body.dark-mode #share-results-button.beginner {
            color: var(--beginner-color) !important;
            border-color: var(--beginner-color);
        }

        body.dark-mode #share-results-button.intermediate {
            color: var(--intermediate-color) !important;
            border-color: var(--intermediate-color);
        }

        body.dark-mode #share-results-button.advanced {
            color: var(--advanced-color) !important;
            border-color: var(--advanced-color);
        }

        body.dark-mode #share-results-button.beginner:hover {
            background-color: var(--beginner-color);
            color: var(--beginner-text-color) !important;
        }

        body.dark-mode #share-results-button.intermediate:hover {
            background-color: var(--intermediate-color);
            color: var(--intermediate-text-color) !important;
        }

        body.dark-mode #share-results-button.advanced:hover {
            background-color: var(--advanced-color);
            color: var(--advanced-text-color) !important;
        }

        /* Add these styles for the input focus state */
        #input.border-beginner:focus {
            border-color: var(--beginner-color);
        }

        #input.border-intermediate:focus {
            border-color: var(--intermediate-color);
        }

        #input.border-advanced:focus {
            border-color: var(--advanced-color);
        }

        #timer-progress-container {
        width: 100%;
        height: 10px;
        background-color: #f0f0f0;
        border-radius: 5px;
        margin-top: 10px;
        margin-bottom: 5px;
        overflow: hidden;
    }

    #timer-progress-bar {
        width: 100%;
        height: 100%;
        transition: width 1s linear, background-color 0.3s ease;
    }

    body.dark-mode #timer-progress-container {
        background-color: #555;
    }

    body.dark-mode #timer-progress-bar {
        filter: brightness(1.2);
    }

    #add-punctuation-checkbox {
        margin-right: 5px;
    }
    
    label {
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #333;
    }

    .dark-mode label {
        color: #f0f0f0;
    }

    .custom-text-modal .modal-buttons button {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    color: white;
    font-weight: bold;
}

.custom-text-modal .modal-buttons button:first-child {
    background-color: #34495e; /* Green for "Start Custom Test" */
}

.custom-text-modal .modal-buttons button:last-child {
    background-color: #d00002; /* Red for "Cancel" */
}

.custom-text-modal .modal-buttons button:hover {
    opacity: 0.8;
}

/* Ensure text is visible in both light and dark modes */
.custom-text-modal .modal-buttons button {
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
}

/* Adjustments for dark mode if needed */
body.dark-mode .custom-text-modal .modal-buttons button {
    border: 1px solid #ffffff3d;
}

/* Add some spacing between buttons */
.custom-text-modal .modal-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

/* Ensure the checkbox and label are clearly visible */
.custom-text-modal label {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
    font-size: 14px;
    color: #333;
}

body.dark-mode .custom-text-modal label {
    color: #f0f0f0;
}

.custom-text-modal input[type="checkbox"] {
    margin-left: 10px;
}

.button-group {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}

.button-group button {
    flex: 1;
    padding: 10px 15px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    color: white;
    font-weight: bold;
    margin: 0 5px;
}

#beginner-btn { background-color: #2ecc71; }
#intermediate-btn { background-color: #3498db; }
#advanced-btn { background-color: #9b59b6; }


.button-group button:hover {
    opacity: 0.8;
    transform: translatez(-2px);
}

/* Dark mode adjustments */
body.dark-mode .button-group button {
    border: 1px solid rgba(255, 255, 255, 0.2);
}

body.dark-mode #custom-text-btn {
    background-color: #d35400;
    border-color: #ffffff;
}

.custom-text-modal .checkbox-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
}

.custom-text-modal .checkbox-container input[type="checkbox"] {
    margin-right: 10px;
}

.custom-text-modal .checkbox-container label {
    display: flex;
    align-items: center;
}














input:checked + .slider:before {
    transform: translateX(26px);
}

body.dark-mode .slider {
    background-color: #555;
}









.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;

}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #333;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.toggle-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 20px;
  color: #333333;
  transition: .4s;
}

input:checked + .slider .toggle-icon {
  left: calc(100% - 15px);
  color: #fff;
}



/* Common styles for dark mode toggle */
input#dark-mode-toggle:checked + .slider:before {
    transform: translateX(26px);
    content: "üåô"; /* Add the crescent moon emoji */
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    filter: grayscale(100%); /* Apply grayscale effect */
}


.switch-small {
    position: relative;
    display: inline-block;
    width: 40px; /* Reduce width */
    height: 20px; /* Reduce height */
    margin-left: 20px;
}

.switch-small input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider-small {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #b1b1b1;
    transition: .4s;
    border-radius: 20px; /* Adjust for new height */
}

.slider-small:before {
    position: absolute;
    content: "";
    height: 14px; /* Reduce size */
    width: 14px; /* Reduce size */
    left: 3px; /* Adjust position */
    bottom: 3px; /* Adjust position */
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider-small {
    background-color: #dcdbdb;
}

input:checked + .slider-small:before {
    transform: translateX(20px); /* Adjust for new width */
}

.toggle-icon-small {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px; /* Reduce font size */
    color: #333;
    transition: .4s;
}

input:checked + .slider-small .toggle-icon-small {
    left: calc(100% - 10px); /* Adjust position */
    color: #fff;
}


/* Default button styles */
button {
    padding: 10px 20px;
    color: white;
    background: #34495e;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
    
}

/* Dark mode styles for buttons */
body.dark-mode button {
    background-color: #444444;
    color: #ffffff;
}

body.dark-mode button:hover {
    background-color: #555555;
}

/* Specific styles for reset progress button */
body.dark-mode #reset-progress {
    background-color: #d00002;
    color: #ffffff;
}

/* Specific styles for view progress button */
body.dark-mode #view-progress-button {
    background-color: #34495e;
    color: #ffffff;
}

/* Specific styles for start button */
body.dark-mode #start-button {
    background-color: #444444;
    color: #ffffff;
}

/* Specific styles for difficulty filter buttons */
body.dark-mode #difficulty-filter button {
    background-color: #333;
    color: #ffffff;
}

body.dark-mode #difficulty-filter button:hover {
    background-color: #444;
}

/* General dark mode styles */
body.dark-mode {
    --beginner-color: #27ae60;
    --intermediate-color: #2980b9;
    --advanced-color: #8e44ad;
    --all-levels-color: #2c3e50;
    --reset-button-color: #d00002; /* Keep the same red color in dark mode */
    --reset-button-text-color: #ffffff;
    background-color: #1a1a1a;
    color: #f0f0f0;
}

/* Apply border colors to input in dark mode */
body.dark-mode #input {
    border-color: #555555; /* Default dark mode border color */
}

body.dark-mode #input.border-beginner {
    border-color: var(--beginner-color);
}

body.dark-mode #input.border-intermediate {
    border-color: var(--intermediate-color);
}

body.dark-mode #input.border-advanced {
    border-color: var(--advanced-color);
}

/* Apply background colors to typing area in dark mode */
body.dark-mode #typing-area {
    background-color: #2c2c2c;
    color: #f0f0f0;
}

/* Update styles for modal buttons in dark mode */
body.dark-mode .modal-buttons button {
    background-color: #444444;
    color: #ffffff;
}

body.dark-mode .modal-buttons button:hover {
    background-color: #555555;
}

/* Ensure buttons in modals also update */
body.dark-mode #resetModal .modal-buttons button#reset-progress {
    background-color: var(--reset-button-color);
    color: var(--reset-button-text-color);
}

/* Ensure dark mode styles are applied to all necessary elements */
body.dark-mode .view-progress-button {
    background-color: #27ae60; /* Dark mode color for 'View Full Progress' */
    color: white;
}

body.dark-mode .close-results-button {
    background-color: #c0392b; /* Dark mode color for 'Close' */
    color: white;
}

body.dark-mode .modal-content {
    background-color: #2c2c2c;
    color: #f0f0f0;
}

body.dark-mode #progress-chart-container {
    background-color: #2c2c2c;
}


.achievement-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #4CAF50;
    color: white;
    padding: 15px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
    animation: slideIn 0.5s ease-out;
}

@keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
}

/* Light mode styles */
.achievement {
    background-color: #f0f0f0;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 10px;
    color: #333;
}

.achievement.unlocked {
    background-color: #e6ffe6;
}

.achievement.locked {
    opacity: 0.7;
}

/* Light mode styles */
.progress-bar {
    width: 100%;
    height: 10px;
    background-color: #e0e0e0; /* Light gray background */
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
}

.progress {
    height: 100%;
    background-color: #4CAF50; /* Green for filling state */
    transition: width 0.5s ease-out, background-color 0.3s ease;
}

.progress.filled {
    background-color: #45a049; /* Darker green for filled state */
}

/* Dark mode styles */
body.dark-mode .progress-bar {
    background-color: #444; /* Darker gray background for dark mode */
}

body.dark-mode .progress {
    background-color: #66bb6a; /* Slightly lighter green for filling state in dark mode */
}

body.dark-mode .progress.filled {
    background-color: #4caf50; /* Green for filled state in dark mode */
}

/* Dark mode styles */
body.dark-mode .achievement {
    background-color: #2c3e50;
    color: #ecf0f1;
}

body.dark-mode .achievement.unlocked {
    background-color: #27ae60;
}

body.dark-mode .achievement.locked {
    opacity: 0.5;
    background-color: #34495e;
}

body.dark-mode .progress-bar {
    background-color: #727272;
}

body.dark-mode .progress {
    background-color: #2ecc71;
}

body.dark-mode .progress-text {
    color: #ecf0f1;
}

body.dark-mode .achievement h4,
body.dark-mode .achievement p {
    color: #ecf0f1;
}




.progress-text {
    font-size: 12px;
    color: #666;
}

#progressModal .modal-content {
    max-height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    z-index: 1001; 
}

.carousel {
    display: flex;
    overflow: hidden;
    width: 100%;
    height: calc(80vh - 60px); /* Adjust height to leave space for buttons */
}

.carousel-page {
    min-width: 100%;
    overflow-y: auto;
    transition: transform 0.5s ease;
    flex-shrink: 0;
    padding: 20px;
    box-sizing: border-box;
}

.carousel-buttons {
    text-align: center;
    margin: 10px 0;
}

#prevBtn, #nextBtn {
    padding: 10px 20px;
    margin: 5px;
}


/* Modal general styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 900px;
    border-radius: 1px;
    position: relative;
    display: flex;
    flex-direction: column;
}

body.black-white-mode .modal-content {
    filter: none;
    margin-top: 600px;
}

body.black-white-mode .modal {
    display: none;
    position: fixed;
    z-index: 1001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    justify-content: center;
    align-items: center;
}




@media (max-width: 600px) {
    .modal-content {
        width: 95%;
        margin: 2% auto;
    }
}

.modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin-top: 20px;
    flex-direction: row;
}

.modal-buttons button {
    flex: 1;
    padding: 10px 20px;
    font-size: 14px;
    height: 50px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.modal-buttons .close-button {
    background-color: #34495e;
    color: white;
}

.modal-buttons #reset-progress {
    background-color: #d00002;
    color: white;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

.achievement-popup {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #4CAF50;
    color: white;
    padding: 15px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
    opacity: 0;
    transform: translateX(100%);
    transition: opacity 0.3s, transform 0.3s;
}

.achievement-popup.show {
    opacity: 1;
    transform: translatex(0);
}

.achievement-popup h3 {
    margin: 0 0 10px 0;
    font-size: 18px;
}

.achievement-popup p {
    margin: 0;
    font-size: 14px;
}

body.dark-mode .achievement-popup {
    background-color: #2c3e50;
    color: #ecf0f1;
}

/* Width */
::-webkit-scrollbar {
  width: 10px;
  border-radius: 10px;
}

/* Track */
::-webkit-scrollbar-track {
  background: #c5c5c5;
  border-radius: 10px;
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: #838383;
  border-radius: 10px;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: #34495e;
  border-radius: 10px;
}

body.dark-mode::-webkit-scrollbar-thumb:hover {
  background: #686b6e;
  border-radius: 10px;
}

body.dark-mode .achievement-notification {
    background-color: #2c3e50;
    color: #ecf0f1;
    box-shadow: 0 2px 10px rgba(255,255,255,0.2);
}


#keyboard-container {
    width: 100%;
    max-width: 800px;
    margin: 20px auto;
    padding: 10px;
    background-color: #f0f0f0;
    border-radius: 5px;
    box-sizing: border-box;
}

.keyboard-row {
    display: flex;
    justify-content: center;
    margin-bottom: 5px;
}

.key {
    flex: 1;
    height: 40px;
    margin: 2px;
    background-color: #ffffff;
    border: 1px solid #cccccc;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    cursor: default;
    user-select: none;
    transition: background-color 0.3s, color 0.3 sbox-shadow 0.1s ease;
}

.key.wide {
    flex: 1.5;
}

.key.extra-wide {
    flex: 2;
}

.key.space {
    flex: 6;
}

/* Dark mode styles */
body.dark-mode #keyboard-container {
    background-color: #2c2c2c;
}

body.dark-mode .key {
    background-color: #444444;
    border-color: #555555;
    color: #ffffff;
}

body.dark-mode .key:hover {
    background-color: #555555;
}

@media (max-width: 600px) {
    .key {
        font-size: 12px;
        height: 35px;
    }
}

.time-selector {
    display: flex;
    justify-content: center;
    margin-bottom: 2px;
    margin-top: 10px;
    font-size: 15px;
}

.time-option {
    padding: 5px 10px;
    margin: 0 5px;
    background-color: #f0f0f0;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.time-option:hover {
    background-color: #e0e0e0;
}

.time-option.selected {
    background-color: var(--highlight-color, #9c9c9c);
    color: white;
}

body.dark-mode .time-option {
    background-color: #444;
    color: #f0f0f0;
}

body.dark-mode .time-option:hover {
    background-color: #555;
}

body.dark-mode .time-option.selected {
    background-color: var(--highlight-color, #9c9c9c);
}

.difficulty-selection-container {
    margin-bottom: 20px;
}

.slider-container {
    width: 100%;
    height: 40px;
    background-color: #e0e0e0;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    margin-bottom: 1px;
}

.slider-option {
    position: absolute;
    width: 33.33%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    color: #333; /* Default text color */
    z-index: 2;
    cursor: pointer;
}

.slider-option.selected {
    color: white; /* Selected text color */
}

/* Ensure dark mode text remains visible */
body.dark-mode .slider-option {
    color: #f0f0f0;
}

body.dark-mode .slider-option.selected {
    color: white;
}

.slider-handle {
    position: absolute;
    width: 33.33%;
    height: 100%;
    background-color: #bcbcbc;
    border-radius: 20px;
    transition: left 0.3s ease-out, background-color 0.3s ease-out;
    pointer-events: none; 
    color: white;
}

.slider-handle.beginner { background-color: var(--beginner-color); }
.slider-handle.intermediate { background-color: var(--intermediate-color); }
.slider-handle.advanced { background-color: var(--advanced-color); }

#custom-text-btn {
    
    background-color: #34495e;
    color: #ffffff;
    width: 48%;
    height: 50px;
    position: relative;
    cursor: pointer;
}

#custom-text-btn:hover {
    background-color: #2c3e50;
}

/* Dark mode styles */
body.dark-mode .slider-container {
    background-color: #444;
}

body.dark-mode .slider-option {
    color: #f0f0f0;
}

body.dark-mode #custom-text-btn {
    background-color: #2c3e50;
}

body.dark-mode #custom-text-btn:hover {
    background-color: #34495e;
}

.top-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5px;
    
}

.difficulty-selection-container {
    flex-grow: 1;
    margin-right: 10px;
    margin-bottom: 0px;
}

.text-size-selector,
.dark-mode-toggle {
    flex-shrink: 0;
}

.stats-group {
    margin-bottom: 14px;
}



#keyboard-layout-container > * {
    margin-right: 10px;
}

.button-group {
    display: flex;
    justify-content: space-between;
}

.button-group button {
    flex: 1;
    margin: 0 5px;
}

.top-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 10px 0;
}

.difficulty-slider {
    flex-grow: 1;
    margin-right: 30px;
    
}

.right-controls {
    display: flex;
    align-items: center;
}

.text-size-selector {
    display: flex;
    align-items: center;
    margin-right: 20px;
}

.text-size-selector label {
    margin-right: 10px;
}

.text-size-selector select {
    padding: 5px 10px;
    border-radius: 5px;
    color: white;
}

.dark-mode-toggle {
    display: flex;
    align-items: center;
}

.switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 34px;
    
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #9d9d9d;
    transition: .4s;
    border-radius: 34px;
    color: white;
}

.slider:before {
    position: absolute;
    content: "";
    height: 26px;
    width: 26px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
    color: white;
}

input:checked + .slider {
    background-color: #3c3c3c;
}

input:checked + .slider:before {
    transform: translateX(26px);
}


.text-size-selector-container {
    position: relative;
    width: 180px;
    height: 40px;
    background-color: #e0e0e0;
    border-radius: 20px;
    overflow: hidden;
    cursor: pointer;
    transition: height 0.3s ease;
    margin-right: 10px;
}

.text-size-selector-container.open {
    height: 200px; /* Increased to accommodate all options */
}

.text-size-selector-button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    padding: 0 10px;
    font-size: 14px;
    
}

.select-text {
    margin-right: 5px;
}

.selected-size {
    font-weight: bold;
}

.text-size-slider-container {
    position: relative;
    width: 100%;
    height: calc(100% - 40px);
}

.text-size-slider-handle {
    position: absolute;
    width: 100%;
    height: 40px;
    background-color: var(--highlight-color, #2ecc71);
    border-radius: 20px;
    transition: all 0.3s ease;
    z-index: 1;
}

.text-size-slider-option {
    position: absolute;
    width: 100%;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    color: #333;
    z-index: 2;
}



.text-size-slider-option:nth-child(2) { top: 0; }
.text-size-slider-option:nth-child(3) { top: 40px; }
.text-size-slider-option:nth-child(4) { top: 80px; }
.text-size-slider-option:nth-child(5) { top: 120px; }

/* Dark mode styles */
body.dark-mode .text-size-selector-container {
    background-color: #444;
}

body.dark-mode .text-size-slider-handle {
    background-color: var(--highlight-color, #27ae60);
}

body.dark-mode .text-size-slider-option {
    color: #f0f0f0;
}

body.dark-mode .text-size-slider-option.selected {
    color: #fff;
}

body.dark-mode .text-size-selector-button {
    color: #f0f0f0;
}

.animated-number {
    font-size: 35px;
    font-weight: bold;
    transition: all 0.5s ease-out;
}

@keyframes countUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.animate {
    animation: countUp 0.5s ease-out;
}

.accuracy-display {
    display: flex;
    flex-direction: column;
    align-items: center;
    
}

.main-accuracy {
    font-size: 24px;
    font-weight: bold;
    
}

.detailed-accuracy {
    font-size: 12px;
    color: #666;
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-top: 5px;
}

.detailed-accuracy span {
    background-color: rgba(0,0,0,0.1);
    padding: 2px 5px;
    border-radius: 3px;
}

/* Dark mode adjustments */
body.dark-mode .detailed-accuracy {
    color: #aaa;
}

body.dark-mode .detailed-accuracy span {
    background-color: rgba(255,255,255,0.1);
}

#word-accuracy {
    display: inline-flex;
    font-size: 14px;
    background-color: rgba(0,0,0,0.1);
    padding: 2px 10px;
    border-radius: 3px;
    margin-right: 1px;
    margin-left: 25px;
    margin-top: 15px;
    
}

#key-accuracy {
    display: inline-flex;
    font-size: 14px;
    background-color: rgba(0,0,0,0.1);
    padding: 2px 10px;
    border-radius: 3px;
    margin-left: 1px;
    margin-top: 15px;
    
}

/* Dark mode adjustments */
body.dark-mode #word-accuracy, 
body.dark-mode #key-accuracy {
    background-color: rgba(255,255,255,0.1);
    color: #aaa;
}

.button-group {
        transition: transform 0.5s ease-out, opacity 0.5s ease-out;
    }

    .button-group.hidden {
        transform: translateY(50px);
        opacity: 0;
        pointer-events: none;
    }


    #input {
    width: 100%;
    box-sizing: border-box;
    padding: 10px;
    margin-bottom: 10px;
    border-width: 2px;
    border-style: solid;
    border-color: #bfbfbf;
    border-radius: 5px;
    font-size: 18px;
    transition: border-color 0.3s ease;
    caret-color: var(--cursor-color, #2ecc71);
    margin-bottom: 18px;
    
}




@keyframes blink {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
}

button:focus, input:focus, select:focus {
    outline: 2px solid var(--highlight-color, #2ecc71);
}


#avg-word-time {
    display: flex;
    font-size: 14px;
    background-color: rgba(0,0,0,0.1);
    padding: 2px 2px;
    border-radius: 3px;
    margin-right: 40px;
    margin-left: 40px;
    margin-top: 15px;
    text-align: center;
    flex-direction: column
    
    
}

/* Dark mode adjustments */
body.dark-mode #avg-word-time {
    background-color: rgba(255,255,255,0.1);
    color: #aaa;
}

#keyboard-layout-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    background-color: #b2b2b2;
    padding: 10px;
    border-radius: 5px;
}

.keyboard-controls {
    display: flex;
    align-items: center;
    gap: 20px; /* Adjust this value to control spacing between elements */
}

#keyboard-heatmap-toggle-container,
.layout-selector,
.toggle-group {
    display: flex;
    align-items: center;
}

.layout-selector label,
.toggle-group .toggle-label {
    margin-right: 10px;
    color: #fff;
    
}

.layout-selector label {
    margin-left: -15px;
}


#keyboard-layout-selector {
    background-color: #444;
    color: #fff;
    border: none;
    padding: 5px;
    border-radius: 3px;
}

#hide-ui-toggle-container {
    margin-left: auto; /* This pushes it to the right */
}

.keyboard-left-controls {
    display: flex;
    align-items: center;
    gap: 20px; /* Adjust as needed */
}

.toggle-group {
    display: flex;
    align-items: center;
    margin-right: 15px;
    margin-left: 73px;
}

.toggle-label {
    margin-left: 5px;
    font-size: 14px;
    color: #fff;
}

.layout-selector {
    display: flex;
    align-items: center;
}



#keyboard-layout-selector {
    background-color: #444;
    margin-left: 5px;
    color: #fff;
    border: none;
    padding: 5px;
    border-radius: 3px;
}

.slider-small {
    background-color: #ccc;
}

.slider-small:before {
    background-color: #fff;
}

input:checked + .slider-small {
    background-color: #34495e;
}

/* Apply grayscale to the entire page except modals */
body.black-white-mode {
    filter: grayscale(100%);
}

.modal {
    z-index: 1005; /* Higher than the body's z-index */
}

body.black-white-mode #progressModal .modal-content {
    max-height: none;
    height: auto;
    overflow: auto;
}



body.black-white-mode #progressModal .modal-content {
    margin: auto;
    max-height: 90vh; /* This allows some space at top and bottom */
    overflow-y: auto;
}



body.hide-ui .stats-group,
body.hide-ui #keyboard-layout-container > *:not(#hide-ui-toggle-container), 
body.hide-ui .button-group,
body.hide-ui h1 {
    display: none;
    transition: 0.5s;
}

body.hide-ui #keyboard-layout-container {
    background-color: transparent;
    padding: 0;
}

body.hide-ui #hide-ui-toggle-container {
    display: flex;
    align-items: center;
}

body.hide-ui #hide-ui-toggle-container .toggle-label {
    display: none;
}

body.hide-ui #typing-area {
    margin-top: 0px;
}

body.hide-ui #test-instructions {
    margin-top: -50px;
    background-color: #34495e00;
    color: #34495e;
    padding: 5px;
    overflow: hidden;
    text-align: center;
    
}

/* Maintain progress bar size in hide UI mode */
#hide-ui-progress-bar {
    width: 100% !important; /* Force full width */
    max-width: none !important; /* Remove any max-width restrictions */
}

/* Ensure the progress bar inner maintains its appearance */
#hide-ui-progress-bar-inner {
    height: 100% !important;
}



/* Adjust position when keyboard heatmap is visible */
body.hide-ui #keyboard-container:not([style*="display: none"]) ~ #test-instructions {
    margin-top: 0px;

}




#test-instructions {
    width: 100%;
    padding: 10px;
    color: #34495e;
    text-align: center;
    border-radius: 5px;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
    margin-top: -50px;
}

body.dark-mode #test-instructions.active {
    opacity: 1;
    transform: translateY(0);
}

body.dark-mode #test-instructions {
    width: 100%;
    padding: 10px;
    background-color: #313336;
    color: white;
    text-align: center;
    border-radius: 5px;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
    margin-top: -50px;
}

#test-instructions.active {
    opacity: 1;
    transform: translateY(0);
    
}

body.dark-mode #test-instructions.active {
    opacity: 1;
    transform: translateY(0);
    background-color: #09832300;
}


.button-group {
    transition: transform 0.5s ease-out, opacity 0.5s ease-out;
}

.button-group.hidden {
    transform: translateY(50px);
    opacity: 0;
    pointer-events: none;
}


body.hide-ui.test-active .top-controls {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    margin-top: 250px;
}

body.hide-ui .top-controls {
    transition: opacity 0.3s ease;
    margin-top: 250px;
}



@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeOutDown {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(20px);
    }
}

body.dark-mode .test-instructions {
    background-color: rgba(51, 51, 51, 0.8);
    color: #f0f0f0;
}

#hide-ui-progress-bar {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 8px;
    background-color: #ddd;
    z-index: 1000;
    overflow: hidden;
}

#hide-ui-progress-bar-inner {
    width: 100%;
    height: 100%;
    background-color: var(--highlight-color, #2ecc71);
    transform-origin: center;
    transform: scaleX(1);
    transition: transform 0.1s linear, background-color 0.3s ease;
}

body.hide-ui.test-active #hide-ui-progress-bar {
    display: block;
}


.stats-group,
.button-group,
h1,
.top-controls {
    transition: opacity 0.3s ease, transform 0.5s ease;
    
}

body.hide-ui .stats-group,
body.hide-ui .button-group,
body.hide-ui h1 {
    opacity: 0;
    transform: translateY(-20px);
    pointer-events: none;
}

.slider-container {
    color: white;
}

.slider-container.test-active {
    opacity: 0.5;
    cursor: not-allowed;
}

@keyframes glowPulse {
    0% { box-shadow: 0 0 5px 2px rgba(255, 255, 0, 0.5); }
    50% { box-shadow: 0 0 20px 10px rgba(255, 255, 0, 0.5); }
    100% { box-shadow: 0 0 5px 2px rgba(255, 255, 0, 0.5); }
}

.difficulty-glow {
    animation: glowPulse 2s infinite;
}

.border-custom {
    border-color: #34495e;
}

#problematic-words-container {
    margin-top: 15px;
    border: 1px solid #ccc;
    padding: 10px;
    border-radius: 5px;
}

#problematic-words-container h3 {
    margin-top: 0;
    font-size: 16px;
}

#problematic-words-list {
    font-style: italic;
    margin-bottom: 10px;
}

#add-problematic-words {
    background-color: #34495e;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
}

#add-problematic-words:hover {
    background-color: #45a049;
}


#difficulty-filter.slider-container {
    width: 100%;
    height: 40px;
    background-color: #e0e0e0;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    margin-bottom: 20px;
}

#difficulty-filter .slider-handle {
    position: absolute;
    width: 25%;
    height: 100%;
    background-color: var(--highlight-color, #2ecc71);
    border-radius: 20px;
    transition: all 0.3s ease;
}

#difficulty-filter .slider-option {
    position: absolute;
    width: 25%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    color: #333;
    z-index: 2;
}

body.dark-mode #difficulty-filter.slider-container {
    background-color: #444;
}

body.dark-mode #difficulty-filter .slider-option {
    color: #f0f0f0;
}


.carousel-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 20px;
}

.nav-button {
  background: none;
  border: none;
  font-size: 24px;
  color: #6b7280;
  cursor: pointer;
}

.nav-dots {
  display: flex;
  margin: 0 20px;
}

.dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: #d1d5db;
  margin: 0 5px;
}

.dot.active {
  background-color: #374151;
}

.carousel {
  position: relative;
  overflow: hidden;
  width: 100%;
}

.carousel-page {
  position: absolute;
  top: 0;
  left: 100%;
  width: 100%;
  transition: left 0.5s ease-in-out;
}

.carousel-page.active {
  left: 0;
}

.carousel-page.prev {
  left: -100%;
}

.carousel-page {
    height: 100%;
    overflow-y: hidden;
}

#page-2 {
    overflow-y: auto;
    max-height: 80vh; /* Adjust this value as needed */
}
        
.trend-arrow {
    margin-left: 5px;
    font-size: 0.8em;
}


#waveVisualizer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  opacity: 0.5;
}

.visualizer-opacity-slider {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    font-family: 'Figtree', sans-serif;
    display: flex;
    align-items: center;
    transition: background-color 0.3s ease;
}

.visualizer-opacity-slider label {
    margin-right: 10px;
    font-weight: bold;
    color: #333;
}

.visualizer-opacity-slider input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100px;
    height: 6px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.7;
    transition: opacity 0.2s;
    border-radius: 3px;
    margin: 0;
    padding: 0;
}


.visualizer-opacity-slider input[type="range"]:hover {
    opacity: 1;
}

.visualizer-opacity-slider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #34495e;
    cursor: pointer;
    border-radius: 50%;
}

.visualizer-opacity-slider input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #34495e;
    cursor: pointer;
    border-radius: 50%;
}

#opacityValue {
    margin-left: 10px;
    font-weight: bold;
    color: #333;
    min-width: 40px;
    text-align: right;
}

/* Dark mode styles */
body.dark-mode .visualizer-opacity-slider {
    background: rgba(51, 51, 51, 0.8);
}

body.dark-mode .visualizer-opacity-slider label,
body.dark-mode #opacityValue {
    color: #f0f0f0;
}

body.dark-mode .visualizer-opacity-slider input[type="range"] {
    background: #555;
}

body.dark-mode .visualizer-opacity-slider input[type="range"]::-webkit-slider-thumb {
    background: #34495e;
}

body.dark-mode .visualizer-opacity-slider input[type="range"]::-moz-range-thumb {
    background: #34495e;
}


#support-icon {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background-color: #f0f0f0;
  padding: 10px;
  border-radius: 5px;
  cursor: pointer;
  display: flex;
  align-items: center;
  z-index: 1000;
}

#support-icon .icon {
  margin-right: 5px;
}

#supportModal {
  display: none;
  position: fixed;
  z-index: 1001;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

#supportModal .modal-content {
  background-color: #fefefe;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 80%;
  max-width: 600px;
  align-items: center;
}

.donate-button {
  display: inline-block;
  padding: 10px 20px;
  background-color: #4CAF50;
  color: white;
  text-decoration: none;
  border-radius: 5px;
  margin-top: 10px;
  text-align: center;
}

.support-close-button {
  background-color: #34495e;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-top: 10px;
}

body.dark-mode #supportModal .modal-content {
  background-color: #333;
  color: #f0f0f0;
  border-color: #555;
}

body.dark-mode .support-close-button {
  background-color: #34495e;
}

body.dark-mode #support-icon {
  position: fixed;
  color: black;
}

.animated-stats {
  transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
}

.hide-ui .animated-stats {
  transform: translateY(-100%);
  opacity: 0;
}

#hide-ui-toggle-container {
  position: relative;
  z-index: 1000;
}

.modal {
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
}


body.black-white-mode #custom-text-modal {
    /* Remove the display: flex from here */
    align-items: center;
    justify-content: center;
}

body.black-white-mode #custom-text-modal.modal-open {
    /* Add this class when the modal is supposed to be open */
    display: flex;
}

body.black-white-mode #custom-text-modal .modal-content {
    margin: auto;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    top: 50%;
    transform: translateY(-50%);
    width: 80%;
    max-width: 800px;
}

body.black-white-mode #custom-text-modal .modal-content {
    margin-top: 5vh;
}

#problematic-words-container,
.custom-text-modal #problematic-words-container {
    margin-top: 15px;
  margin-bottom: 10px;
  padding: 15px;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 5px;
  max-height: 150px; /* Adjust as needed */
  overflow-y: auto;
}

#problematic-words-container h3,
.custom-text-modal #problematic-words-container h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 16px;
    color: #333;
}

#problematic-words-list,
.custom-text-modal #problematic-words-list {
    min-height: 20px;
    word-wrap: break-word;
    color: #333;
    margin-bottom: 10px;
}

.problematic-word {
    display: inline-block;
    margin: 3px;
    padding: 3px 8px;
    background-color: #e0e0e0;
    border-radius: 15px;
    font-size: 14px;
}

/* Dark mode styles */
body.dark-mode #problematic-words-container,
body.dark-mode .custom-text-modal #problematic-words-container {
    background-color: #2c2c2c;
    border-color: #444;
}

body.dark-mode #problematic-words-list,
body.dark-mode .custom-text-modal #problematic-words-list {
    color: #f0f0f0;
}

body.dark-mode .problematic-word {
    background-color: #444;
    color: #f0f0f0;
}


.custom-text-modal .modal-content {
  width: 90%; /* Increase from the current value */
  max-width: 800px; /* Increase if necessary */
  max-height: 90vh; /* Ensure it doesn't exceed the viewport height */
  overflow-y: auto; /* Allow scrolling if content exceeds height */
}

.custom-text-modal .modal-content {
    max-width: 800px;
    width: 90%;
    padding: 20px;
}

.custom-text-modal .input-section {
    margin-bottom: 20px;
}

.custom-text-modal textarea {
    width: 97%;
    height: 150px;
    margin-bottom: 10px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.custom-text-modal .checkbox-container {
    margin-bottom: 10px;
}

.custom-text-modal .options-section {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
}

.custom-text-modal .random-words-options,
.custom-text-modal #custom-problematic-words-container {
    flex: 1;
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
}

.custom-text-modal .difficulty-checkboxes {
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
}

.custom-text-modal .difficulty-checkboxes label {
    margin-bottom: 5px;
}

.custom-text-modal button {
    padding: 8px 15px;
    margin-top: 5px;
    background-color: #34495e;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.custom-text-modal button:hover {
    background-color: #2c3e50;
}

.custom-text-modal .modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
}

.custom-text-modal .modal-buttons button {
    flex: 1;
}

.custom-text-modal .modal-buttons button:last-child {
    background-color: #e74c3c;
}

.custom-text-modal .modal-buttons button:last-child:hover {
    background-color: #c0392b;
}

/* Dark mode styles */
body.dark-mode .custom-text-modal .random-words-options,
body.dark-mode .custom-text-modal #custom-problematic-words-container {
    background-color: #2c2c2c;
}

body.dark-mode .custom-text-modal textarea {
    background-color: #333;
    color: #f0f0f0;
    border-color: #555;
}

body.dark-mode .custom-text-modal button {
    background-color: #4a6f8a;
}

body.dark-mode .custom-text-modal button:hover {
    background-color: #5d8aad;
}

body.dark-mode .custom-text-modal .modal-buttons button:last-child {
    background-color: #9c2e2e;
}

body.dark-mode .custom-text-modal .modal-buttons button:last-child:hover {
    background-color: #b93636;
}

#progress-problematic-words-container .problematic-word {
    display: inline-block;
    margin: 3px;
    padding: 3px 8px;
    background-color: #e0e0e0;
    border-radius: 15px;
    font-size: 14px;
    border: 2px solid;
}

#progress-problematic-words-container .problematic-word.beginner { border-color: var(--beginner-color); }
#progress-problematic-words-container .problematic-word.intermediate { border-color: var(--intermediate-color); }
#progress-problematic-words-container .problematic-word.advanced { border-color: var(--advanced-color); }

/* Styles for custom text modal problematic words (without borders) */
#custom-problematic-words-container .problematic-word {
    display: inline-block;
    margin: 3px;
    padding: 3px 8px;
    background-color: #e0e0e0;
    border-radius: 15px;
    font-size: 14px;
}

/* Dark mode styles */
body.dark-mode #progress-problematic-words-container .problematic-word,
body.dark-mode #custom-problematic-words-container .problematic-word {
    background-color: #444;
    color: #f0f0f0;
}

.key {
    transition: background-color 0.1s ease, box-shadow 0.1s ease;
}

body.dark-mode .key {
    color: #ffffff;
    background-color: #444444;
}

.tooltip-trigger {
    position: relative;
    display: inline-block;
    cursor: help;
    margin-left: 5px;
    font-size: 0.8em;
    color: #666;
}

.tooltip-text {
    visibility: hidden;
    width: 300px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    margin-left: -150px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 0.9em;
    font-weight: normal;
}

.tooltip-trigger:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

/* Dark mode styles */
body.dark-mode .tooltip-text {
    background-color: #333;
    color: #f0f0f0;
}

.active-achievement {
    position: fixed;
    z-index: 1000;
    background-color: rgba(255, 215, 0, 0.9);
    color: #000;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    opacity: 0;
    transition: opacity 0.5s, transform 0.5s;
    box-shadow: 0 0 20px gold;
}

.active-achievement.show {
    opacity: 1;
}

.active-achievement h3 {
    margin: 0 0 10px 0;
}

.active-achievement p {
    font-size: 40px;
    margin: 0;
}


    </style>

</head>

<body>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0/dist/chartjs-plugin-annotation.min.js"></script>
    
    <canvas id="waveVisualizer"></canvas>
    <h1>Ultimate WPM Typing Speed Test</h1>
    <div id="hide-ui-progress-bar">
        <div id="hide-ui-progress-bar-inner"></div>
    </div>
    <div class="top-controls">
        <div class="difficulty-selection-container">
            <div class="slider-container" id="difficultySlider">
                <div class="slider-handle"></div>
                <div class="slider-option" style="left: 0%">Beginner</div>
                <div class="slider-option" style="left: 33.33%">Intermediate</div>
                <div class="slider-option" style="left: 66.66%">Advanced</div>
            </div>
        </div>
        <div class="text-size-selector-container">
            <div class="text-size-selector-button">
                <span class="select-text">Select text size</span>
                <span class="selected-size"></span>
            </div>
            <div class="text-size-slider-container" id="textSizeSlider">
                <div class="text-size-slider-handle"></div>
                <div class="text-size-slider-option" data-size="18">Small</div>
                <div class="text-size-slider-option" data-size="24">Medium</div>
                <div class="text-size-slider-option" data-size="30">Large</div>
                <div class="text-size-slider-option" data-size="36">Extra Large</div>
            </div>
        </div>
        <div class="dark-mode-toggle">
            <label class="switch">
                <input type="checkbox" id="dark-mode-toggle">
                <span class="slider round"></span>
            </label>
        </div>
    </div>
    
    <div id="typing-area">Select a difficulty to begin.
        
    </div>
    
        <input type="text" id="input" placeholder="Let's get typing..." disabled>
    
        <div class="stats-group animated-stats">
        <div id="time-left" class="stats-item">
            <strong>Time left:</strong>
            <div id="timer">60 seconds</div>    
            <div id="timer-progress-container">
                <div id="timer-progress-bar"></div>
            </div>
            <div id="time-selector" class="time-selector">
                <span class="time-option" data-time="30">30s</span>
                <span class="time-option" data-time="60">1m</span>
                <span class="time-option" data-time="120">2m</span>
                <span class="time-option" data-time="180">3m</span>
                <span class="time-option" data-time="300">5m</span>
                <span class="time-option" data-time="600">10m</span>
            </div>       
        </div>
        <div id="wpm-box" class="stats-item">
            <strong>WPM:</strong>
            <div id="wpm" class="animated-number">0</div>
            <span id="avg-word-time" title="Average Time Spent on Word">Avg. Word Time: 0.0s</span>
        </div>
        <div id="accuracy-box" class="stats-item">
    <strong>Accuracy:</strong>
    <div id="accuracy" class="animated-number">100%</div>
    <span id="word-accuracy" title="Word Accuracy">Word:100%</span>
    <span id="key-accuracy" title="Key Accuracy">Key:100%</span>
</div>
    </div>
    <button id="start-button" onclick="checkDifficulty()" title="Please select a difficulty level before starting the test">Start Test</button>
    
    
    
    <div id="keyboard-layout-container">
        <div class="keyboard-controls">
            <div id="keyboard-heatmap-toggle-container">
                <label class="switch-small">
                    <input type="checkbox" id="keyboard-heatmap-toggle" onchange="toggleHeatmap()">
                    <span class="slider-small"></span>
                </label>
            </div>
            <div class="layout-selector">
                <label for="keyboard-layout-selector">Keyboard Layout:</label>
                <select id="keyboard-layout-selector" onchange="changeKeyboardLayout()">
                    <option value="qwerty">QWERTY</option>
                    <option value="dvorak">Dvorak</option>
                    <option value="colemak">Colemak</option>
                    <option value="qwertz">QWERTZ</option>
                    <option value="azerty">AZERTY</option>
                </select>
            </div>
            <div class="toggle-group">
                <label class="switch-small">
                    <input type="checkbox" id="black-white-toggle" onchange="toggleBlackWhiteMode()">
                    <span class="slider-small"></span>
                </label>
                <span class="toggle-label">Black & White Mode</span>
            </div>
        </div>
        <div id="hide-ui-toggle-container" class="toggle-group">
            <label class="switch-small">
                <input type="checkbox" id="hide-ui-toggle" onchange="toggleUIVisibility()">
                <span class="slider-small"></span>
            </label>
            <span class="toggle-label">Hide UI</span>
        </div>
    </div>
    
    
    <div id="keyboard-container" style="display: none;"></div>
    
    


    <div class="button-group">
        <button id="custom-text-btn" onclick="openCustomTextModal()">Use Custom Text</button>
        <button id="view-progress-button" onclick="openProgressModal()">View Progress</button>
    </div>
    
    <div id="test-instructions">Press Enter to reset the test. Press ESC to cancel.</div>


    <div id="results" class="modal">
        <div class="modal-content">
            <div id="result-content"></div>
            <div class="modal-buttons">
                <button class="view-progress-button" onclick="openProgressModal()">View Full Progress</button>
                <button class="close-results-button" onclick="closeModal('results')">Close</button>
            </div>
        </div>
    </div>

    <div id="progressModal" class="modal">
        <div class="modal-content">
            <div class="carousel">
                <!-- Page 1: Typing Progress -->
                <div class="carousel-page" id="page-1">
                    <h2>Your Typing Progress</h2>
                    <div id="difficulty-filter" class="slider-container">
                        <div class="slider-handle"></div>
                        <div class="slider-option" style="left: 0%">All Levels</div>
                        <div class="slider-option" style="left: 25%">Beginner</div>
                        <div class="slider-option" style="left: 50%">Intermediate</div>
                        <div class="slider-option" style="left: 75%">Advanced</div>
                    </div>
    
                    <div id="stats">
                        <div class="stat">
                            <h3>Average WPM</h3>
                            <p id="avg-wpm">0</p>
                        </div>
                        <div class="stat">
                            <h3>Average Accuracy</h3>
                            <p id="avg-accuracy">0%</p>
                        </div>
                        <div class="stat">
                            <h3>Highest WPM</h3>
                            <p id="highest-wpm">0</p>
                            <p id="highest-wpm-difficulty" style="font-size: 14px; margin-top: 5px;"></p>
                        </div>
                        <div class="stat">
                            <h3>Compared to Average</h3>
                            <p id="compared-to-average">0 WPM</p>
                        </div>
                        <div class="stat">
                            <h3>Compared to Professional</h3>
                            <p id="compared-to-professional">0 WPM</p>
                        </div>
                    </div>
    
                    <div id="time-filter">
                        <label for="time-range-selector">Time Range:</label>
                        <select id="time-range-selector" onchange="filterByTimeRange()">
                            <option value="today">Today</option>
                            <option value="7">7 days</option>
                            <option value="30">30 days</option>
                            <option value="90">90 days</option>
                            <option value="180">6 months</option>
                            <option value="365">12 months</option>
                            <option value="all">All time</option>
                        </select>
                    </div>
                    <div id="progress-chart-container">
                        <canvas id="progress-chart"></canvas>
                    </div>
    
                    <!-- Add problematic words section here -->
                    <div id="progress-problematic-words-container">
                        <h3>
                            Top 10 Challenging Words
                            <span class="tooltip-trigger">‚ìò
                                <span class="tooltip-text">Challenging words are calculated based on the frequency of errors and the time spent on each word across all your typing tests. Words that consistently cause errors or slow down your typing are ranked higher on this list.</span>
                            </span>
                        </h3>
                        <p id="progress-problematic-words-list"></p>
                    </div>
                </div>
    
                <!-- Page 2: Achievements -->
                <div class="carousel-page" id="page-2">
                    <h2>Achievements</h2>
                    <div id="achievements-container"></div>
                </div>
            </div>
    
            <div class="carousel-nav">
                <button class="nav-button prev">&lt;</button>
                <div class="nav-dots">
                    <span class="dot active"></span>
                    <span class="dot"></span>
                </div>
                <button class="nav-button next">&gt;</button>
            </div>
    
            <div class="modal-buttons">
                <button id="reset-progress" onclick="openResetModal()">Reset Progress</button>
                <button class="close-button" onclick="closeModal('progressModal')">Close</button>                
            </div>
            <div id="disclaimer">
                <p>Disclaimer: Your progress data is stored locally in your browser. Clearing your browser data or using a different device may result in loss of progress.</p>
            </div>
        </div>
    </div>

    <div class="visualizer-opacity-slider">
        <label for="opacitySlider">Visualizer Opacity:</label>
        <input type="range" id="opacitySlider" min="0" max="100" value="50">
        <span id="opacityValue">50%</span>
      </div>


    <div id="supportModal" class="modal">
        <div class="modal-content">
          <h2>Support</h2>
          <p>Thank you for taking the time and interest to try this typing test. If you're anything like me, you enjoy using these typing tests to improve your typing efficiency and have something to do while at work or school. This typing test was created for just that purpose: to demonstrate your progress and provide achievements to challenge you even further. If you enjoy the app, please consider donating. Your support will help me improve this app and develop better apps in the future.</p>
          <p>Thank you.‚ù§Ô∏è</p>
          <script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Support Me on Ko-fi', '#29abe0', 'M4M610PZ8N');kofiwidget2.draw();</script> 
          <button class="support-close-button">Close</button>
        </div>
      </div>
    

      <div id="custom-text-modal" class="modal custom-text-modal">
        <div class="modal-content">
            <h2>Custom Text Input</h2>
            <div class="input-section">
                <textarea id="custom-text-input" rows="8" placeholder="Paste your custom text here or use random words..."></textarea>
                <div class="checkbox-container">
                    <label>
                        <input type="checkbox" id="add-punctuation-checkbox">
                        Add random punctuation
                    </label>
                </div>
            </div>
            <div class="options-section">
                <div class="random-words-options">
                    <h4>Random Words Options:</h4>
                    <div class="difficulty-checkboxes">
                        <label><input type="checkbox" id="beginner-words-checkbox" checked> Beginner</label>
                        <label><input type="checkbox" id="intermediate-words-checkbox" checked> Intermediate</label>
                        <label><input type="checkbox" id="advanced-words-checkbox" checked> Advanced</label>
                    </div>
                    <button id="generate-random-words">Generate Random Words</button>
                </div>
                <div id="custom-problematic-words-container">
                    <h4>Top 10 Challenging Words:</h4>
                    <p id="custom-problematic-words-list"></p>
                    <button id="custom-add-problematic-words">Add to Custom Text</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button onclick="startCustomTextTest()">Start Custom Test</button>
                <button onclick="closeModal('custom-text-modal')">Cancel</button>
            </div>
        </div>
    </div>

    <div id="results" class="modal">
        <div class="modal-content">
            <div id="result-content"></div>
            <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 20px;">
                <button onclick="openProgressModal()" style="flex: 1; padding: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">View Full Progress</button>
                <button onclick="closeModal('results')" style="flex: 1; padding: 10px; background-color: #d9534f; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>
    <div id="resetModal" class="modal">
        <div class="modal-content">
            <h2>Confirm Reset</h2>
            <p>Are you sure you want to reset your progress? This action cannot be undone.</p>
            <div class="modal-buttons">
                <button onclick="resetProgress()">Yes, Reset</button>
                <button onclick="closeModal('resetModal')">Cancel</button>
            </div>
        </div>
    </div>

    <div id="chartPointModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeChartPointModal()">&times;</span>
            <div id="chart-point-content"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.min.js"></script>
    <script>
    const achievements = [
        {
            id: 'first_10_wpm',
            name: 'First 10 WPM',
            description: 'Achieve a typing speed of 10 WPM',
            condition: (results) => results.some(r => r.wpm >= 10),
            progressCalculation: (results) => Math.min(100, Math.max(...results.map(r => r.wpm)) / 10 * 100)
        },
        {
            id: 'consistent_95_accuracy',
            name: 'Consistent 95% Accuracy',
            description: 'Maintain an accuracy of 95% or higher for five consecutive tests',
            condition: (results) => {
                let consecutiveCount = 0;
                for (let i = results.length - 1; i >= 0; i--) {
                    if (results[i].accuracy >= 95) {
                        consecutiveCount++;
                        if (consecutiveCount === 5) return true;
                    } else {
                        break;
                    }
                }
                return false;
            },
            progressCalculation: (results) => {
                let consecutiveCount = 0;
                for (let i = results.length - 1; i >= 0; i--) {
                    if (results[i].accuracy >= 95) {
                        consecutiveCount++;
                        if (consecutiveCount === 5) break;
                    } else {
                        break;
                    }
                }
                return Math.min(100, (consecutiveCount / 5) * 100);
            }
        },
        {
            id: 'first_1000_words',
            name: 'First 1000 Words',
            description: 'Type a total of 1000 words',
            condition: (results) => results.reduce((sum, r) => sum + r.totalWords, 0) >= 1000,
            progressCalculation: (results) => Math.min(100, (results.reduce((sum, r) => sum + r.totalWords, 0) / 1000) * 100)
        },
        {
            id: 'no_mistakes',
            name: 'No Mistakes',
            description: 'Complete a test with zero mistakes',
            condition: (results) => results.some(r => r.accuracy === 100),
            progressCalculation: (results) => {
                return results.some(r => r.accuracy === 100) ? 100 : 0;
            }
        },
        {
            id: 'warm_up',
            name: 'Warm-Up',
            description: 'Complete your first typing test',
            condition: (results) => results.length >= 1,
            progressCalculation: (results) => results.length > 0 ? 100 : 0
        },
        {
            id: '10_tests_completed',
            name: '10 Tests Completed',
            description: 'Complete 10 typing tests',
            condition: (results) => results.length >= 10,
            progressCalculation: (results) => Math.min(100, (results.length / 10) * 100)
        },
        {
            id: 'speed_booster',
            name: 'Speed Booster',
            description: 'Improve your typing speed by 5 WPM over any three tests',
            condition: (results) => {
                for (let i = 2; i < results.length; i++) {
                    if (results[i].wpm >= results[i-2].wpm + 5) return true;
                }
                return false;
            },
            progressCalculation: (results) => {
                let maxImprovement = 0;
                for (let i = 2; i < results.length; i++) {
                    maxImprovement = Math.max(maxImprovement, results[i].wpm - results[i-2].wpm);
                }
                return Math.min(100, (maxImprovement / 5) * 100);
            }
        },
        {
            id: 'precision_typist',
            name: 'Precision Typist',
            description: 'Achieve 100% accuracy in any test',
            condition: (results) => results.some(r => r.accuracy === 100),
            progressCalculation: (results) => {
                return results.some(r => r.accuracy === 100) ? 100 : 0;
            }
        },
        {
            id: 'daily_practice',
            name: 'Daily Practice',
            description: 'Complete a test every day for a week',
            condition: (results) => {
                const lastWeek = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                const dailyTests = new Set(results.filter(r => new Date(r.date) > lastWeek).map(r => new Date(r.date).toDateString()));
                return dailyTests.size >= 7;
            },
            progressCalculation: (results) => {
                const lastWeek = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                const dailyTests = new Set(results.filter(r => new Date(r.date) > lastWeek).map(r => new Date(r.date).toDateString()));
                return Math.min(100, (dailyTests.size / 7) * 100);
            }
        },
        {
            id: 'reach_40_wpm',
            name: 'Reach 40 WPM',
            description: 'Achieve a typing speed of 40 WPM',
            condition: (results) => results.some(r => r.wpm >= 40),
            progressCalculation: (results) => Math.min(100, Math.max(...results.map(r => r.wpm)) / 40 * 100)
        },
        {
            id: 'accuracy_expert',
            name: 'Accuracy Expert',
            description: 'Maintain an accuracy of 98% or higher for 10 consecutive tests',
            condition: (results) => {
                let consecutiveTests = 0;
                for (let i = results.length - 1; i >= 0; i--) {
                    if (results[i].accuracy >= 98) {
                        consecutiveTests++;
                        if (consecutiveTests === 10) return true;
                    } else {
                        break;
                    }
                }
                return false;
            },
            progressCalculation: (results) => {
                const recentTests = results.slice(-10);
                const consecutiveAccurateTests = recentTests.filter(r => r.accuracy >= 98).length;
                return Math.min(100, (consecutiveAccurateTests / 10) * 100);
            }
        },
        {
            id: '5000_words_typed',
            name: '5000 Words Typed',
            description: 'Type a total of 5000 words',
            condition: (results) => results.reduce((sum, r) => sum + r.totalWords, 0) >= 5000,
            progressCalculation: (results) => Math.min(100, (results.reduce((sum, r) => sum + r.totalWords, 0) / 5000) * 100)
        },
        {
            id: 'no_errors_streak',
            name: 'No Errors Streak',
            description: 'Complete five tests in a row with zero mistakes',
            condition: (results) => results.slice(-5).every(r => r.accuracy === 100),
            progressCalculation: (results) => {
                const streak = results.slice().reverse().findIndex(r => r.accuracy !== 100);
                return Math.min(100, (streak === -1 ? results.length : streak) / 5 * 100);
            }
        },
        {
            id: 'speed_enthusiast',
            name: 'Speed Enthusiast',
            description: 'Improve your typing speed by 10 WPM over any five tests',
            condition: (results) => {
                for (let i = 4; i < results.length; i++) {
                    if (results[i].wpm >= results[i-4].wpm + 10) return true;
                }
                return false;
            },
            progressCalculation: (results) => {
                let maxImprovement = 0;
                for (let i = 4; i < results.length; i++) {
                    maxImprovement = Math.max(maxImprovement, results[i].wpm - results[i-4].wpm);
                }
                return Math.min(100, (maxImprovement / 10) * 100);
            }
        },
        {
            id: 'frequent_tester',
            name: 'Frequent Tester',
            description: 'Complete 50 typing tests',
            condition: (results) => results.length >= 50,
            progressCalculation: (results) => Math.min(100, (results.length / 50) * 100)
        },
        {
            id: 'intermediate_typist',
            name: 'Intermediate Typist',
            description: 'Maintain an average typing speed of 30 WPM over 10 tests',
            condition: (results) => {
                if (results.length < 10) return false;
                const last10 = results.slice(-10);
                return last10.reduce((sum, r) => sum + r.wpm, 0) / 10 >= 30;
            },
            progressCalculation: (results) => {
                if (results.length < 10) return 0;
                const last10 = results.slice(-10);
                const avgWpm = last10.reduce((sum, r) => sum + r.wpm, 0) / 10;
                return Math.min(100, (avgWpm / 30) * 100);
            }
        },
        {
            id: 'precision_master',
            name: 'Precision Master',
            description: 'Achieve 100% accuracy in 5 tests',
            condition: (results) => results.filter(r => r.accuracy === 100).length >= 5,
            progressCalculation: (results) => {
                const perfectTests = results.filter(r => r.accuracy === 100).length;
                return Math.min(100, (perfectTests / 5) * 100);
            }
        },
        {
            id: 'speed_runner',
            name: 'Speed Runner',
            description: 'Complete a test with a typing speed of 50 WPM',
            condition: (results) => results.some(r => r.wpm >= 50),
            progressCalculation: (results) => Math.min(100, Math.max(...results.map(r => r.wpm)) / 50 * 100)
        },
        {
            id: 'test_marathon',
            name: 'Test Marathon',
            description: 'Complete three tests back-to-back without a break',
            condition: (results) => {
                for (let i = 2; i < results.length; i++) {
                    const test1 = new Date(results[i-2].date);
                    const test2 = new Date(results[i-1].date);
                    const test3 = new Date(results[i].date);
                    if ((test2 - test1) <= 90000 && (test3 - test2) <= 90000) return true;
                }
                return false;
            },
            progressCalculation: (results) => {
                let maxConsecutive = 0;
                for (let i = 1; i < results.length; i++) {
                    const timeDiff = new Date(results[i].date) - new Date(results[i-1].date);
                    if (timeDiff <= 90000) {
                        maxConsecutive++;
                    } else {
                        maxConsecutive = 0;
                    }
                    if (maxConsecutive >= 2) return 100;
                }
                return Math.min(100, (maxConsecutive / 2) * 100);
            }
        },
        {
            id: 'master_typist',
            name: 'Master Typist: 80 WPM',
            description: 'Achieve a typing speed of 80 WPM',
            condition: (results) => results.some(r => r.wpm >= 80),
            progressCalculation: (results) => Math.min(100, Math.max(...results.map(r => r.wpm)) / 80 * 100)
        },
        {
            id: '10000_words_typed',
            name: '10000 Words Milestone',
            description: 'Type a total of 10000 words',
            condition: (results) => results.reduce((sum, r) => sum + r.totalWords, 0) >= 10000,
            progressCalculation: (results) => Math.min(100, (results.reduce((sum, r) => sum + r.totalWords, 0) / 10000) * 100)
        },
        {
            id: 'nooice',
            name: 'NOOICE',
            description: 'Get 69 WPM or 69% Overall accuracy',
            hidden: true,
            condition: (results) => results.some(r => r.wpm === 69 || r.accuracy === 69),
            progressCalculation: (results) => {
                const closestWpm = Math.min(...results.map(r => Math.abs(r.wpm - 69)));
                const closestAccuracy = Math.min(...results.map(r => Math.abs(r.accuracy - 69)));
                const closestOverall = Math.min(closestWpm, closestAccuracy);
                return Math.max(0, 100 - closestOverall);
            }
        },
        {
            id: 'reach_100_wpm',
            name: 'Speed Demon',
            description: 'Achieve a typing speed of 100 WPM',
            condition: (results) => results.some(r => r.wpm >= 100),
            progressCalculation: (results) => results.some(r => r.wpm >= 100) ? 100 : 0
        },

        {
        id: 'flow_state',
        name: 'Flow State',
        description: "You've tapped into the rhythm of typing. A hidden power has been unlocked.",
        hidden: true,
        condition: (results) => {
            const highAccuracyTests = results.filter(r => r.accuracy >= 90).length;
            if (highAccuracyTests >= 20) return true;
            
            const longTests = results.filter(r => r.duration >= 300);
            return longTests.some(test => {
                const halfwayPoint = test.duration / 2;
                return test.accuracyAtHalfway >= 90;
            });
        },
        onUnlock: () => {
            unlockWaveVisualizer();
        }
    }
];

    class AchievementSystem {
    constructor() {
        this.unlockedAchievements = this.loadUnlockedAchievements();
    }

    loadUnlockedAchievements() {
        const saved = localStorage.getItem('unlockedAchievements');
        return saved ? JSON.parse(saved) : [];
    }

    saveUnlockedAchievements() {
        localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));
    }

    checkAchievements(latestResult, allResults) {
    const newAchievements = [];
    achievements.forEach(achievement => {
        if (!this.unlockedAchievements.includes(achievement.id) && achievement.condition(allResults)) {
            this.unlockedAchievements.push(achievement.id);
            newAchievements.push(achievement);
            if (achievement.onUnlock) {
                achievement.onUnlock();
            }
        }
    });
    this.saveUnlockedAchievements();
    return newAchievements;
}

getProgress(achievementId) {
        const achievement = achievements.find(a => a.id === achievementId);
        if (!achievement) return 0;

        // If the achievement is already unlocked, return 100%
        if (this.unlockedAchievements.includes(achievementId)) {
            return 100;
        }

        const results = JSON.parse(localStorage.getItem('typingResults')) || [];
        let progress = 0;

        if (typeof achievement.progressCalculation === 'function') {
            progress = Math.round(achievement.progressCalculation(results));
        } else if (achievement.hidden) {
            progress = achievement.condition(results) ? 100 : 0;
        } else {
            console.warn(`Progress calculation not defined for achievement: ${achievementId}`);
            progress = 0;
        }

        // Special handling for specific achievements
        if (['no_mistakes', 'precision_typist', 'reach_100_wpm', 'nooice', 'master_typist', 'speed_runner', 'reach_40_wpm', 'first_10_wpm'].includes(achievement.id)) {
            progress = Math.max(0, progress);  // Ensure progress is not negative
        }

        return progress;
    }

    updateProgressModal() {
        const achievementsContainer = document.getElementById('achievements-container');
        if (!achievementsContainer) return;

        achievementsContainer.innerHTML = '';
        const isDarkMode = document.body.classList.contains('dark-mode');

        achievements.forEach(achievement => {
            // Skip hidden achievements that are not yet unlocked
            if (achievement.hidden && !this.unlockedAchievements.includes(achievement.id)) {
                return;
            }

            const isUnlocked = this.unlockedAchievements.includes(achievement.id);
            const progress = isUnlocked ? 100 : this.getProgress(achievement.id);

            const achievementElement = document.createElement('div');
            achievementElement.className = `achievement ${isUnlocked ? 'unlocked' : 'locked'} ${isDarkMode ? 'dark-mode' : ''}`;
            
            let achievementContent = `
                <h4>${achievement.name}</h4>
                <p>${achievement.description}</p>
            `;

            if (!achievement.hidden) {
                achievementContent += `
                    <div class="progress-bar">
                        <div class="progress" style="width: ${progress}%"></div>
                    </div>
                    <span class="progress-text">${progress}%</span>
                `;
            }

            achievementElement.innerHTML = achievementContent;
            achievementsContainer.appendChild(achievementElement);
        });
    }

    displayNewAchievements(newAchievements) {
        const displayDuration = 3000; // 3 seconds
        const displayQueue = newAchievements.slice(); // Create a copy of the array

        const showNextAchievement = () => {
            if (displayQueue.length > 0) {
                const achievement = displayQueue.shift(); // Get the next achievement
                this.showAchievementNotification(achievement);

                // Schedule the next achievement
                setTimeout(() => {
                    showNextAchievement();
                }, displayDuration);
            }
        };

        // Start displaying achievements
        showNextAchievement();
    }

    showAchievementNotification(achievement) {
        console.log(`New achievement unlocked: ${achievement.name}`);
        const popup = document.createElement('div');
        popup.className = 'achievement-popup';
        popup.innerHTML = `
            <h3>Achievement Unlocked!</h3>
            <p>${achievement.name}</p>
            <p>${achievement.description}</p>
        `;

        document.body.appendChild(popup);

        setTimeout(() => {
            popup.classList.add('show');
        }, 10);

        setTimeout(() => {
            popup.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(popup);
            }, 300);
        }, 2700); // Remove slightly before the next one appears
    }

    resetProgress() {
        this.unlockedAchievements = [];
        this.saveUnlockedAchievements();
        this.updateProgressModal();
    }
}

function updateAchievements(latestResult) {
    const allResults = JSON.parse(localStorage.getItem('typingResults')) || [];
    allResults.push(latestResult); // Add the latest result to all results
    const newAchievements = achievementSystem.checkAchievements(latestResult, allResults);
    
    if (newAchievements.length > 0) {
        console.log('New achievements unlocked:', newAchievements);
        achievementSystem.displayNewAchievements(newAchievements);
    }

    achievementSystem.updateProgressModal();
}


        const beginnerWords = [
            "the", "be", "to", "of", "and", "a", "in", "that", "I", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at", "this", "but", "his", "by", "from", "we", "say", "her", "she", "or", "an", "will", "my", "one", "all", "so", "up", "out", "if", "who", "get", "go", "me", "when", "make", "can", "like", "time", "no", "just", "him", "know", "take", "into", "year", "your", "good", "some", "them", "see", "other", "than", "then", "now", "look", "only", "come", "its", "over", "think", "also", "back", "use", "two", "how", "our", "work", "well", "way", "even", "new", "want", "any", "these", "give", "day", "most", "us", "is", "was", "were", "been", "have", "had", "do", "did", "done", "say", "said", "go", "went", "gone", "see", "saw", "seen", "eat", "ate", "run", "ran", "put", "read", "let", "old", "both", "told", "held", "felt", "left", "kept", "slept", "fell", "deal", "hear", "sold", "cut", "hurt", "quit", "pay", "laid", "said", "led", "met", "feed", "bleed", "breed", "speed", "mean", "deal", "dream", "grow", "wear", "born", "cost", "beat", "hit", "Agent", "Kain"
        ];

        const intermediateWords = [
            ...beginnerWords,
            "about", "above", "add", "after", "again", "air", "almost", "along", "always", "animal", "answer", "are", "around", "ask", "away", "because", "began", "begin", "being", "below", "between", "big", "book", "both", "boy", "call", "came", "car", "carry", "change", "children", "city", "close", "country", "cut", "different", "does", "down", "each", "earth", "end", "enough", "every", "example", "eye", "face", "family", "far", "father", "feet", "few", "find", "first", "follow", "food", "form", "found", "four", "girl", "great", "group", "grow", "hand", "hard", "has", "head", "hear", "help", "here", "high", "home", "house", "idea", "important", "keep", "kind", "land", "large", "last", "later", "learn", "leave", "left", "letter", "life", "light", "line", "list", "little", "live", "long", "made", "man", "many", "may", "mean", "men", "might", "mile", "miss", "more", "mother", "mountain", "move", "much", "must", "name", "near", "need", "never", "next", "night", "number", "off", "often", "oil", "once", "open", "own", "page", "paper", "part", "people", "picture", "place", "plant", "play", "point", "put", "question", "quick", "quickly", "quite", "read", "really", "right", "river", "same", "school", "sea", "second", "seem", "sentence", "set", "should", "show", "side", "small", "something", "sometimes", "song", "soon", "sound", "spell", "start", "state", "still", "stop", "story", "study", "such", "take", "tell", "their", "thing", "think", "those", "thought", "three", "through", "together", "too", "took", "tree", "try", "turn", "until", "very", "walk", "watch", "water", "white", "why", "without", "word", "world", "would", "write", "young",
            "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "today", "tomorrow", "yesterday", "week", "month", "year", "schedule", "appointment", "meeting", "deadline",
            "it's", "I'm", "don't", "can't", "you're", "I've", "I'd", "I'll", "you've", "you'd", "you'll"
        ];

        const advancedWords = [
            ...intermediateWords,
            ...beginnerWords,
            "curriculum", "syllabus", "academia", "dissertation", "thesis", "laboratory", "experiment", "hypothesis", "theory",
            "synthesis", "evaluation", "critical", "thinking", "problem", "solving", "brainstorming", "collaboration", "teamwork", "leadership",
            "organization", "prioritization", "multitasking", "presentation", "speaking",
            "writing", "skills", "research", "methods", "data", "statistics", "qualitative", "quantitative", "methodology",
            "literature", "review", "peer", "publication", "journal", "conference", "symposium", "workshop", "seminar",
            "lecture", "tutorial", "mentorship", "apprenticeship", "internship", "practicum", "fieldwork", "case", "study",
            "entrepreneurship", "innovation", "creativity", "strategic", "project", "management",
            "risk", "assessment", "quality", "control", "continuous", "improvement", "professional", "development",
            "networking", "conflict", "resolution", "making", "skills,",
            "emotional", "adaptability", "flexibility", "resilience", "motivation", "discipline",
            "stress", "balance", "ethics", "corporate", "social", "responsibility",
            "sustainability", "globalization", "inclusion", "competence", "cross", "cultural", "communication",
            "international", "relations", "diplomacy", "policy", "governance", "administration", "human", "resources",
            "finance", "accounting", "marketing", "sales", "service", "public", "advertising",
            "brand", "consumer", "behavior", "supply", "chain", "operations",
            "assurance", "benchmarking", "practices", "industry", "standards", "regulatory", "compliance",
            "intellectual", "property", "copyright", "trademark", "patent", "licensing", "contract", "negotiation",
            "mergers", "acquisitions", "venture", "capital", "angel", "investing", "crowdfunding", "bootstrapping",
            "revenue", "model", "business", "proposition", "competitive", "advantage", "market", "segmentation",
            "target", "audience", "customer", "lifetime", "value", "return", "investment",
            "key", "performance", "indicators", "metrics", "analytics", "driven", "decision", "artificial", "intelligence",
            "machine", "learning", "blockchain", "cryptocurrency", "internet", "things", "cloud", "computing", "cybersecurity",
            "privacy", "information", "security", "digital", "transformation", "agile", "lean", "principles",
            "six", "sigma", "total", "change", "organizational", "corporate,", "culture",
            "employee", "engagement", "talent", "acquisition", "retention", "succession", "planning",
            "compensation", "benefits", "workplace", "diversity", "equal", "opportunity", "affirmative", "action", "labor", "laws",
            "collective", "bargaining", "union", "representation", "occupational", "health", "safety", "ergonomics", "wellness", "programs",
            "wouldn't", "shouldn't", "couldn't", "won't", "we're", "they're", "he's", "she's", "that's", "there's",
            "who's", "what's", "where's", "when's", "how's", "we've", "we'd", "we'll", "they've",
            "they'd", "they'll", "wasn't", "weren't", "hasn't", "haven't", "hadn't", "doesn't", "didn't",
            "company's", "team's", "project's", "client's", "market's", "industry's", "year's", "month's", "week's",
            "day's", "manager's", "employee's", "customer's", "product's", "service's", "country's", "world's",
            "technology's", "science's", "research's", "data's", "analysis", "strategy's", "policy's", "law's",
            "tomorrow's", "future's", "today's", "nation's", "region's", "city's", "community's", "family's", "parent's", "child's",
        ];

        let words = [];
        let currentWordIndex = 0;
        let startTime;
        let timer;
        let timerInterval;
        let correctWords = 0;
        let totalWords = 0;
        let totalKeystrokes = 0;
        let testActive = false;
        let timerStarted = false;
        let currentDifficulty = null;
        let wordErrors = {};
        let correctKeystrokes = 0;
        let incorrectKeystrokes = 0;
        let currentHighlightColor = null;
        let currentWordKeystrokes = 0;
        let currentWordErrors = 0;
        let afkTimer;
        let lastInputTime;
        let keyPressCount = {};
        let currentPage = 0;
        let keystrokeData = [];
        let wordTimings = {};
        let wordData = {};
        let afkInterval;
        let typingResults = JSON.parse(localStorage.getItem('typingResults')) || [];
        let currentWordCorrectKeystrokes = 0;
        let wpmData = [];
        let errorTimeStamps = [];
        let keyboardLayout = 'qwerty';
        let heatmapEnabled = false; // Ensure heatmapEnabled is defined globally
        let currentLayout = 'qwerty';
        let selectedTime = 60; // Default to 60 seconds
        let updateInterval;
        let originalCustomText = '';
        let wordErrorTracker = {};
        let lastKnownValues = { 'avg-wpm': {}, 'avg-accuracy': {} };
        let currentPageIndex = 0;
        let resultSaved = false;
        let originalData = []; // Store the original dataset here when you first load it
        let currentFilteredData = []; // This will hold the currently filtered data
        let lastUsedDifficulty = 'beginner'; // Default to beginner
        let isResultModalOpen = false;
        let isCustomTest = true;
        let isProgressModalOpen = false;
        let isCustomTextSelected = false;
        let difficultySelected = false;
        let recentlyClosedProgressModal = false;
        let sessionProblematicWords = {};
        let visualizer;
        let waveVisualizerUnlocked = false;
        


        const typingArea = document.getElementById('typing-area');
        const input = document.getElementById('input');
        const startButton = document.getElementById('start-button');
        const timerDisplay = document.getElementById('timer');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const resultsDisplay = document.getElementById('results');
        const resultContent = document.getElementById('result-content');
        const AFK_TIMEOUT = 10000; // 10 seconds
        const keyboardToggle = document.getElementById('keyboard-heatmap-toggle');
        const MAX_INTENSITY = 10; // Maximum number of presses for full color intensity
        const achievementSystem = new AchievementSystem();
        const sliderContainer = document.getElementById('difficultySlider');
        const customTextBtn = document.getElementById('custom-text-btn');
        const difficultyFilter = document.getElementById('difficulty-filter');
        const sliderHandle = difficultyFilter.querySelector('.slider-handle');
        const sliderOptions = difficultyFilter.querySelectorAll('.slider-option');
        const mainSliderContainer = document.getElementById('difficultySlider');
        const mainSliderHandle = mainSliderContainer.querySelector('.slider-handle');
        const progressSliderContainer = document.getElementById('difficulty-filter');
        const progressSliderHandle = progressSliderContainer.querySelector('.slider-handle');
        const CUSTOM_TEST_COLOR = '#34495e';
        const ALPHA = 0.2; // Weighting factor for moving average
        const AVERAGE_WORD_LENGTH = 5; // Adjust based on your dataset
        const ONE_DAY = 24 * 60 * 60 * 1000; // milliseconds in a day
        const ONE_WEEK = 7 * 24 * 60 * 60 * 1000; // One week in milliseconds
        const MAX_TESTS = 100;
        const problematicWords = getTopProblematicWords(10, true);
        const problematicWordsData = getTopProblematicWords(10, false);



        const AVERAGE_TYPING_SPEED = 40;
        const PROFESSIONAL_TYPING_SPEED = 80;
        const DIFFICULTY_COLORS = {
            beginner: '#2ecc71',
            intermediate: '#3498db',
            advanced: '#9b59b6'
        };
        const layouts = {
            qwerty: [
                "`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "Backspace",
                "Tab", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
                "CapsLock", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "Enter",
                "Shift", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "Shift",
                "Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"
            ],
            dvorak: [
                "`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "[", "]", "Backspace",
                "Tab", "'", ",", ".", "p", "y", "f", "g", "c", "r", "l", "/", "=", "\\",
                "CapsLock", "a", "o", "e", "u", "i", "d", "h", "t", "n", "s", "-", "Enter",
                "Shift", ";", "q", "j", "k", "x", "b", "m", "w", "v", "z", "Shift",
                "Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"
            ],
            colemak: [
                "`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "Backspace",
                "Tab", "q", "w", "f", "p", "g", "j", "l", "u", "y", ";", "[", "]", "\\",
                "CapsLock", "a", "r", "s", "t", "d", "h", "n", "e", "i", "o", "'", "Enter",
                "Shift", "z", "x", "c", "v", "b", "k", "m", ",", ".", "/", "Shift",
                "Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"
            ],
            qwertz: [
                "`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "√ü", "'", "Backspace",
                "Tab", "q", "w", "e", "r", "t", "z", "u", "i", "o", "p", "√º", "+", "\\",
                "CapsLock", "a", "s", "d", "f", "g", "h", "j", "k", "l", "√∂", "√§", "Enter",
                "Shift", "<", "y", "x", "c", "v", "b", "n", "m", ",", ".", "-", "Shift",
                "Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"
            ],
            azerty: [
                "¬≤", "&", "√©", "\"", "'", "(", "-", "√®", "_", "√ß", "√†", ")", "=", "Backspace",
                "Tab", "a", "z", "e", "r", "t", "y", "u", "i", "o", "p", "^", "$", "\\",
                "CapsLock", "q", "s", "d", "f", "g", "h", "j", "k", "l", "m", "√π", "Enter",
                "Shift", "<", "w", "x", "c", "v", "b", "n", ",", ";", ":", "!", "Shift",
                "Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"
            ]
        };

        

    // Initialize elements with 0
    document.getElementById('compared-to-average').innerHTML = '0 WPM';
    document.getElementById('compared-to-professional').innerHTML = '0 WPM';

    // Disable the typing input initially
    input.disabled = true;

    function shuffleWords(wordList) {
        return wordList.sort(() => 0.5 - Math.random());
    }

    function resetWordList() {
    if (currentDifficulty !== 'custom') {
        words = [];
        switch(currentDifficulty) {
            case 'beginner':
                words = shuffleWords(beginnerWords);
                break;
            case 'intermediate':
                words = shuffleWords(intermediateWords);
                break;
            case 'advanced':
                words = shuffleWords(addRandomPunctuation(advancedWords));
                break;
            default:
                words = shuffleWords(beginnerWords);
        }
    }
    currentWordIndex = 0;
}

    function displayWords() {
    if (currentDifficulty === 'custom') {
        if (currentWordIndex >= words.length) {
            // Reset to the beginning for custom tests
            currentWordIndex = 0;
        }
    } else {
        if (words.length === 0 || currentWordIndex >= words.length) {
            refillWords();
        }
    }

    // Display the next set of 10 words
    const wordsToDisplay = words.slice(currentWordIndex, currentWordIndex + 10);
    typingArea.innerHTML = wordsToDisplay.map((word, index) =>
        `<span class="word ${index === 0 ? 'current-word' : ''}" ${index === 0 ? 'id="current-word"' : ''}>${word}</span>`
    ).join(' ');

    // Ensure the current word is visible
    const currentWordElement = document.getElementById('current-word');
    if (currentWordElement) {
        currentWordElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Ensure the input is focused
    input.focus();
}


    function updateToggleIcon() {
        const icon = document.querySelector('.toggle-icon');
        icon.textContent = document.body.classList.contains('togglr-icon') ? '' : '‚å®Ô∏è';
        }


        // Current word selection process (simplified)
        function shuffleWords(wordList) {
            return wordList.sort(() => 0.5 - Math.random());
        }

        function closeProgressModal() {
            const modal = document.getElementById('progressModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('modal-open');
            }
            isProgressModalOpen = false;
            if (lastUsedDifficulty) {
                setDifficulty(lastUsedDifficulty);
                updateDifficultyUI(lastUsedDifficulty);
            } else {
                setDifficulty('beginner');
                updateDifficultyUI('beginner');
            }
        }



function updateProgressModalProblematicWords() {
    const problematicWordsList = document.getElementById('progress-problematic-words-list');
    if (problematicWordsList) {
        const problematicWords = getTopProblematicWords(10, false);
        if (problematicWords.length > 0) {
            const wordList = problematicWords.map((item, index) => 
                `<span class="problematic-word ${item.difficulty}" style="border-color: var(--${item.difficulty}-color);">
                    ${index + 1}. ${item.word}
                </span>`
            ).join(' ');
            problematicWordsList.innerHTML = wordList;
        } else {
            problematicWordsList.textContent = 'No challenging words found yet.';
        }
    }
}
function updateCustomTextModalProblematicWords() {
    const problematicWords = getTopProblematicWords(10, true);
    const problematicWordsList = document.getElementById('custom-problematic-words-list');
    if (problematicWordsList) {
        if (problematicWords.length > 0) {
            const wordList = problematicWords.map((word, index) => 
                `<span class="problematic-word">${index + 1}. ${word}</span>`
            ).join(' ');
            problematicWordsList.innerHTML = wordList;
        } else {
            problematicWordsList.textContent = 'No challenging words found yet.';
        }
    }
}

        

function setDifficulty(level) {
    lastUsedDifficulty = level;
    currentDifficulty = level;
    console.log(`Setting difficulty to: ${level}`);
    currentDifficulty = level;
    updateTypingAreaText();
    updateUIForDifficulty(level);

    const difficultyColor = getDifficultyColor(level);
    if (visualizer) {
        visualizer.updateColor(difficultyColor);
    }

    const input = document.getElementById('input');
    let highlightColor = level === 'custom' 
        ? '#34495e' 
        : getComputedStyle(document.documentElement).getPropertyValue(`--${level}-color`).trim();

    input.style.setProperty('--cursor-color', highlightColor);
    currentHighlightColor = highlightColor;
    document.documentElement.style.setProperty('--highlight-color', currentHighlightColor);

    // Update the slider
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    
    if (sliderHandle && sliderOptions.length === 3 && level !== 'custom') {
        // Only update slider for non-custom difficulties
        let position;
        let index;
        switch (level) {
            case 'beginner':
                position = '0%';
                index = 0;
                break;
            case 'intermediate':
                position = '33.33%';
                index = 1;
                break;
            case 'advanced':
                position = '66.66%';
                index = 2;
                break;
            default:
                position = '0%';
                index = 0;
        }
        sliderHandle.style.left = position;
        sliderHandle.className = `slider-handle ${level}`;
        sliderHandle.style.backgroundColor = highlightColor;

        sliderOptions.forEach((option, i) => {
            option.classList.toggle('selected', i === index);
        });
    }

    // Update input border color
    input.style.borderColor = currentHighlightColor;

    // Update start button color
    updateStartButtonStyle();

    // Update time selector color
    const timeSelector = document.getElementById('time-selector');
    if (timeSelector) {
        timeSelector.style.borderColor = currentHighlightColor;
    }

    // Update progress bar color
    updateProgressBar(selectedTime);
}

        function refillWords() {
            if (currentDifficulty === 'custom') {
                // For custom tests, reset to the original custom text
                words = originalCustomText.split(/\s+/);
                if (getPunctuationState()) {
                    words = addRandomPunctuation(words);
                }
            } else {
                // For predefined difficulties, refill and shuffle
                switch(currentDifficulty) {
                    case 'beginner':
                        words = shuffleWords(beginnerWords);
                        break;
                    case 'intermediate':
                        words = shuffleWords(intermediateWords);
                        break;
                    case 'advanced':
                        words = shuffleWords(addRandomPunctuation(advancedWords));
                        break;
                    default:
                        words = shuffleWords(beginnerWords);
                }
            }
            currentWordIndex = 0; // Reset the index when refilling words
        }


        function setCustomTextMode() {
            currentDifficulty = 'custom';
            updateUIForDifficulty('custom');
            const customColor = '#34495e';
            
            const input = document.getElementById('input');
            input.style.setProperty('--cursor-color', customColor);
            currentHighlightColor = customColor;
            document.documentElement.style.setProperty('--highlight-color', currentHighlightColor);

            // Update input border color
            input.style.borderColor = currentHighlightColor;

            // Update start button color
            updateStartButtonStyle();

            // Update time selector color
            const timeSelector = document.getElementById('time-selector');
            if (timeSelector) {
                timeSelector.style.borderColor = currentHighlightColor;
            }

            // Update progress bar color
            updateProgressBar(selectedTime);

            // Reset slider to neutral state
            const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
            if (sliderHandle) {
                sliderHandle.style.left = '0%';
                sliderHandle.className = 'slider-handle';
                sliderHandle.style.backgroundColor = '#bcbcbc'; // Neutral color
            }

            // Reset option colors
            const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
            sliderOptions.forEach(option => {
                option.classList.remove('selected');
                option.style.color = '';
            });
        }



        

        function getPunctuationState() {
            return document.getElementById('add-punctuation-checkbox').checked;
        }


        // Helper function to get words based on current difficulty
        function getCurrentDifficultyWords() {
            switch(currentDifficulty) {
                case 'beginner':
                    return beginnerWords;
                case 'intermediate':
                    return intermediateWords;
                case 'advanced':
                    return advancedWords;
                default:
                    return beginnerWords; // Default to beginner if somehow no difficulty is set
            }
        }

        function adjustModalPosition() {
            const modal = document.querySelector('.modal');
            const modalContent = modal.querySelector('.modal-content');
            
            // Reset any previous adjustments
            modalContent.style.marginTop = '10%';
            
            // Check if the modal is partially off-screen
            const modalRect = modalContent.getBoundingClientRect();
            if (modalRect.top < 0) {
                // Adjust the margin to bring it into view
                const adjustment = Math.abs(modalRect.top) + 20; // 20px extra for padding
                modalContent.style.marginTop = `calc(10% + ${adjustment}px)`;
            }
        }

        


        function initializeTimeSelector() {
            const timeSelector = document.getElementById('time-selector');
            const timerDisplay = document.getElementById('timer'); // Assuming this is where the time is displayed

            timeSelector.addEventListener('click', (e) => {
                if (e.target.classList.contains('time-option')) {
                    // Get the selected time in seconds
                    selectedTime = parseInt(e.target.dataset.time);
                    
                    // Remove 'selected' class from all options
                    document.querySelectorAll('.time-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add 'selected' class to clicked option
                    e.target.classList.add('selected');
                    
                    // Update the timer display
                    updateTimeLeftDisplay(selectedTime);
                    
                    // Update the progress bar (if you have one)
                    updateProgressBar(selectedTime);
                }
            });

            // Set default selected time (60 seconds in this example)
            document.querySelector('.time-option[data-time="60"]').classList.add('selected');
            updateTimeLeftDisplay(60); // Initialize with default time
        }

    

function openCustomTextModal() {
    var modal = document.getElementById("custom-text-modal");
    if (modal) {
        modal.style.display = "block";
        modal.classList.add('modal-open');

        // Populate problematic words
        updateCustomTextModalProblematicWords();

        // Add event listener to the "Add to Custom Text" button for problematic words
        const addButton = document.getElementById('custom-add-problematic-words');
        if (addButton) {
            addButton.addEventListener('click', function() {
                const customTextInput = document.getElementById('custom-text-input');
                const problematicWords = getTopProblematicWords(10, true); // Get words only
                const currentWords = customTextInput.value.split(/\s+/);
                const newWords = [...currentWords, ...problematicWords].slice(0, 100);
                customTextInput.value = newWords.join(' ');
            });
        } else {
            console.error("Add to Custom Text button not found");
        }

        // Add event listener to the "Generate Random Words" button
        const generateButton = document.getElementById('generate-random-words');
        if (generateButton) {
            generateButton.addEventListener('click', function() {
                const customTextInput = document.getElementById('custom-text-input');
                const randomWords = generateRandomWords().split(/\s+/).slice(0, 100);
                customTextInput.value = randomWords.join(' ');
            });
        } else {
            console.error("Generate Random Words button not found");
        }
    } else {
        console.error("Custom text modal not found");
    }

    setCustomTextMode();
    updateCustomTextModalProblematicWords();
}



function startCustomTextTest() {
    let customText = document.getElementById('custom-text-input').value.trim();
    
    if (customText.length === 0) {
        alert("Please enter some text before starting the custom test.");
        return;
    }
    
    // Split the text into words and limit to 100
    let words = customText.split(/\s+/).slice(0, 100);
    customText = words.join(' ');
    
    originalCustomText = customText;
    words = customText.split(/\s+/);
    if (getPunctuationState()) {
        words = addRandomPunctuation(words);
    }

    currentWordIndex = 0;
    currentDifficulty = 'custom';
    setDifficulty('custom');
    closeModal('custom-text-modal');
    startTest(true);
    document.body.classList.add('custom-test-active');
}
        function resetCustomTextMode() {
            isCustomTextSelected = false;
            const customTextBtn = document.getElementById('custom-text-btn');
            if (customTextBtn) {
                customTextBtn.classList.remove('selected');
            }
            // Hide custom text error message if it exists
            const customTextError = document.getElementById('custom-text-error');
            if (customTextError) {
                customTextError.style.display = 'none';
            }
            // Reset custom text input field if it exists
            const customTextInput = document.getElementById('custom-text-input');
            if (customTextInput) {
                customTextInput.value = '';
            }
        }

    
        function removeDifficultyGlow() {
            const difficultySlider = document.getElementById('difficultySlider');
            difficultySlider.classList.remove('difficulty-glow');
            difficultySelected = true;
        }

        function resetKeyboardBorder() {
            const keys = document.querySelectorAll('.key');
            keys.forEach(key => {
                key.style.borderColor = 'transparent';
            });
            setDifficulty(currentDifficulty);
        }

        function updateTypingAreaText() {
            const typingArea = document.getElementById('typing-area');
            const isMac = /Mac/i.test(navigator.platform);
            
            if (!currentDifficulty) {
                typingArea.textContent = "Select difficulty to begin";
            } else {
                const actionKey = isMac ? "Return" : "Enter";
                typingArea.textContent = `Click 'Start Test' or press ${actionKey} to begin`;
            }
        }

        function handleSliderClick(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = (x / rect.width) * 100;
            let position, difficulty;

            if (percentage < 33.33) {
                position = 0;
                difficulty = 'beginner';
            } else if (percentage < 66.66) {
                position = 33.33;
                difficulty = 'intermediate';
            } else {
                position = 66.66;
                difficulty = 'advanced';
            }

            updateDifficulty(position, difficulty);
            resetCustomTextMode(); // Reset custom text mode when a difficulty is selected
        }


        function handleKeyPress(event) {
            if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
                if (!testActive) {
                    event.preventDefault();
                    updateDifficultyWithArrows(event.key);
                }
            }
        }

sliderContainer.addEventListener('click', handleSliderClick);

        function setDifficulty(level) {
            currentDifficulty = level;
            updateTypingAreaText();

            const input = document.getElementById('input');
            input.style.setProperty('--cursor-color', `var(--${level}-color)`);

            // Set highlight color
            currentHighlightColor = getComputedStyle(document.documentElement).getPropertyValue(`--${level}-color`).trim();
            document.documentElement.style.setProperty('--highlight-color', currentHighlightColor);

            // Update progress bar color immediately
            updateProgressBar(selectedTime);

            // Update key border colors
            updateKeyBorderColors(currentHighlightColor);

            // Update start button color
            updateStartButtonStyle();
            
            // Update UI for the new difficulty
            updateUIForDifficulty(level);

            // Update slider position and class
            const sliderHandle = document.querySelector('.slider-handle');
            const sliderOptions = document.querySelectorAll('.slider-option');
            if (sliderHandle && sliderOptions.length === 3) {
                let position;
                let index;
                switch (level) {
                    case 'beginner':
                        position = '0%';
                        index = 0;
                        break;
                    case 'intermediate':
                        position = '33.33%';
                        index = 1;
                        break;
                    case 'advanced':
                        position = '66.66%';
                        index = 2;
                        break;
                    default:
                        position = '0%';
                        index = 0;
                }
                sliderHandle.style.left = position;
                sliderHandle.className = `slider-handle ${level}`;
                sliderHandle.style.backgroundColor = currentHighlightColor;

                // Update selected state for slider options
                sliderOptions.forEach((option, i) => {
                    option.classList.toggle('selected', i === index);
                });
            }

            // Enable start button and input
            startButton.disabled = false;
            startButton.title = "Click to start the test";
            input.disabled = false;

            // Update input border color
            input.style.borderColor = currentHighlightColor;

            // Set words based on difficulty
            switch (level) {
                case 'beginner':
                    words = shuffleWords(beginnerWords);
                    break;
                case 'intermediate':
                    words = shuffleWords(intermediateWords);
                    break;
                case 'advanced':
                    words = shuffleWords(addRandomPunctuation(advancedWords));
                    break;
            }

            // Update progress bar if test is not active
            if (!testActive) {
                updateProgressBar(selectedTime);
            }
        }

        function updateKeyBorderColors(color) {
            const keys = document.querySelectorAll('.key');
            keys.forEach(key => {
                key.style.borderColor = color;
            });

            // Also update the input border color if needed
            const input = document.getElementById('input');
            if (input) {
                input.style.borderColor = color;
            }

            // Update any other elements that should reflect the current difficulty color
            document.documentElement.style.setProperty('--highlight-color', color);
        }

function updateCursorPosition() {
    const input = document.getElementById('input');
    const cursorPosition = input.selectionStart;
    const text = input.value.substring(0, cursorPosition);
    const textWidth = getTextWidth(text, getComputedStyle(input).font);

    input.style.setProperty('--cursor-left', `${textWidth}px`);
    animateCursor();
}

function getTextWidth(text, font) {
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
    const context = canvas.getContext('2d');
    context.font = font;
    return context.measureText(text).width;
}

function animateCursor() {
    const input = document.getElementById('input');
    input.style.setProperty('--cursor-scale', '1.2');
    setTimeout(() => {
        input.style.setProperty('--cursor-scale', '1');
    }, 100);
}

function changeKeyboardLayout() {
    const layoutSelector = document.getElementById('keyboard-layout-selector');
    currentLayout = layoutSelector.value;
    const keyboardContainer = document.getElementById('keyboard-container');
    keyboardContainer.innerHTML = ''; // Clear existing keys

    // Define different layouts
    const layouts = {
        qwerty: 'QWERTYUIOPASDFGHJKLZXCVBNM',
        dvorak: 'PYFGCRLAOEUIDHTNSQJKXBMWVZ',
        colemak: 'QWFPGLUYARSTDHNEIOZXCVBMJK',
        qwertz: 'QWERTZUIOPASDFGHJKLYXCVBNM',
        azerty: 'AZERTYUIOPQSDFGHJKLMWXCVBN'
    };

    const keys = layouts[currentLayout];
    for (let key of keys) {
        const keyElement = document.createElement('div');
        keyElement.className = 'key';
        keyElement.id = `key-${key}`; // Assign an ID to each key element
        keyElement.textContent = key;
        keyboardContainer.appendChild(keyElement);
    }

    initializeKeyboard();
    updateKeyboardColors();

    if (heatmapEnabled) {
        updateHeatmap(); // Update heatmap based on the new layout
    }
}

function checkDifficulty() {
    if (!currentDifficulty) {
        currentDifficulty = 'beginner'; // Set a default difficulty
    }
    startTest(currentDifficulty === 'custom');
}
    


    function changePage(n) {
        const pages = document.querySelectorAll('.carousel-page');
        currentPage += n;
        
        if (currentPage < 0) {
            currentPage = pages.length - 1;
        } else if (currentPage >= pages.length) {
            currentPage = 0;
        }
        
        const offset = -currentPage * 100;
        pages.forEach(page => {
            page.style.transform = `translateX(${offset}%)`;
        });
    }


    function showPreviousPage() {
        if (currentPageIndex > 0) {
            currentPageIndex--;
            showPage(currentPageIndex);
        }
        }

function showNextPage() {
  const totalPages = document.querySelectorAll('.carousel-page').length;
  if (currentPageIndex < totalPages - 1) {
    currentPageIndex++;
    showPage(currentPageIndex);
  }
}

function showPage(index) {
  const pages = document.querySelectorAll('.carousel-page');
  pages.forEach((page, i) => {
    if (i === index) {
      page.classList.add('active');
      page.classList.remove('prev');
    } else if (i < index) {
      page.classList.add('prev');
      page.classList.remove('active');
    } else {
      page.classList.remove('active', 'prev');
    }
  });
  updateDots();
}

function updateDots() {
  const dots = document.querySelectorAll('.dot');
  dots.forEach((dot, index) => {
    dot.classList.toggle('active', index === currentPageIndex);
  });
}





let lastUpdateTime = 0;
const UPDATE_INTERVAL = 100; // Update every 100ms

function updateProgressBar(timeLeft) {
    const now = performance.now();
    if (now - lastUpdateTime < UPDATE_INTERVAL) return;
    lastUpdateTime = now;

    const progressBar = document.getElementById('timer-progress-bar');
    const hideUiProgressBar = document.getElementById('hide-ui-progress-bar-inner');
    const percentage = timeLeft / selectedTime;

    progressBar.style.width = `${percentage * 100}%`;

    // Determine the color based on current difficulty
    let barColor;
    if (currentDifficulty === 'custom') {
        barColor = '#34495e'; // Use custom color for custom tests
    } else if (timeLeft > selectedTime / 2) {
        barColor = currentHighlightColor;
    } else if (timeLeft > selectedTime / 6) {
        barColor = '#FFC107'; // Yellow
    } else {
        barColor = '#F44336'; // Red
    }

    progressBar.style.backgroundColor = barColor;

    // Update hide UI progress bar
    if (hideUiProgressBar) {
        hideUiProgressBar.style.transform = `scaleX(${percentage})`;
        hideUiProgressBar.style.backgroundColor = barColor;
    }
}


    function updateTimer() {
        const minutes = Math.floor(timer / 60);
        const seconds = Math.floor(timer % 60);
        const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        timerDisplay.textContent = formattedTime;
        }

    function updateTimeLeftDisplay(timeInSeconds) {
    const timerDisplay = document.getElementById('timer');
    
    if (timeInSeconds < 60) {
        // If less than a minute, display in seconds
        timerDisplay.textContent = `${timeInSeconds} seconds`;
    } else {
        // If a minute or more, display in minutes
        const minutes = Math.floor(timeInSeconds / 60);
        timerDisplay.textContent = `${minutes} minute${minutes > 1 ? 's' : ''}`;
    }
}

    function resetAfkTimer() {
        lastInputTime = Date.now();
        clearTimeout(afkTimer);
        afkTimer = setTimeout(() => {
            if (testActive) {
                cancelSession("AFK? Session won't be counted due to inactivity.");
            }
        }, AFK_TIMEOUT);

    }

    function checkAfk() {
        if (testActive && Date.now() - lastInputTime > AFK_TIMEOUT) {
            cancelSession("AFK? Session won't be counted due to inactivity.");
        }
    }

    function toggleBlackWhiteMode() {
        const blackWhiteToggle = document.getElementById('black-white-toggle');
        blackWhiteToggle.checked = !blackWhiteToggle.checked;
        document.body.classList.toggle('black-white-mode', blackWhiteToggle.checked);
        localStorage.setItem('blackWhiteMode', blackWhiteToggle.checked);
    }

    function generateRandomWords() {
        const beginnerChecked = document.getElementById('beginner-words-checkbox').checked;
        const intermediateChecked = document.getElementById('intermediate-words-checkbox').checked;
        const advancedChecked = document.getElementById('advanced-words-checkbox').checked;
        
        let wordPool = [];
        if (beginnerChecked) wordPool = wordPool.concat(beginnerWords);
        if (intermediateChecked) wordPool = wordPool.concat(intermediateWords);
        if (advancedChecked) wordPool = wordPool.concat(advancedWords);
        
        // Remove duplicates
        wordPool = [...new Set(wordPool)];
        
        // Shuffle the word pool
        wordPool = shuffleWords(wordPool);
        
        // Select exactly 100 words
        const selectedWords = wordPool.slice(0, 100);
        
        return selectedWords.join(' ');
    }


    function initializeProgressDifficultySlider() {
    const progressSliderContainer = document.getElementById('difficulty-filter');
    const progressSliderHandle = progressSliderContainer.querySelector('.slider-handle');
    const sliderOptions = progressSliderContainer.querySelectorAll('.slider-option');

    progressSliderContainer.addEventListener('click', (e) => {
        const rect = progressSliderContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        let position, difficulty;

        if (percentage < 25) {
            position = 0;
            difficulty = 'all';
        } else if (percentage < 50) {
            position = 25;
            difficulty = 'beginner';
        } else if (percentage < 75) {
            position = 50;
            difficulty = 'intermediate';
        } else {
            position = 75;
            difficulty = 'advanced';
        }

        progressSliderHandle.style.left = `${position}%`;
        
        // Update the selected state of options
        sliderOptions.forEach((option, index) => {
            option.classList.toggle('selected', index === position / 25);
        });

        filterByDifficulty(difficulty);
    });

    // Set initial position to 'all'
    progressSliderHandle.style.left = '0%';
    sliderOptions[0].classList.add('selected');
    filterByDifficulty('all');
}

    progressSliderContainer.addEventListener('click', (e) => {
        const rect = progressSliderContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        let position, difficulty;

        if (percentage < 25) {
            position = 0;
            difficulty = 'all';
        } else if (percentage < 50) {
            position = 25;
            difficulty = 'beginner';
        } else if (percentage < 75) {
            position = 50;
            difficulty = 'intermediate';
        } else {
            position = 75;
            difficulty = 'advanced';
        }

        progressSliderHandle.style.left = `${position}%`;
        
        // Update the selected state of options
        sliderOptions.forEach((option, index) => {
            option.classList.toggle('selected', index === position / 25);
        });

        filterByDifficulty(difficulty);
    });

    function toggleUIVisibility() {
    const hideUIToggle = document.getElementById('hide-ui-toggle');
    const hideUI = !document.body.classList.contains('hide-ui'); // Toggle the current state

    // Update checkbox state
    hideUIToggle.checked = hideUI;

    // Toggle class on body
    document.body.classList.toggle('hide-ui', hideUI);

    // Update localStorage
    localStorage.setItem('hideUI', hideUI);

    // Update the title of the toggle
    hideUIToggle.title = hideUI ? "Show UI" : "Hide UI";

    if (hideUI) {
        // Wait for the animation to complete before removing elements from the DOM
        setTimeout(() => {
            document.querySelectorAll('.stats-group, .button-group, h1').forEach(el => {
                if (el.id !== 'hide-ui-toggle-container') {
                    el.style.display = 'none';
                }
            });
        }, 300); // 300ms matches the transition duration
    } else {
        // Immediately make elements visible when showing UI
        document.querySelectorAll('.stats-group, .button-group, h1, .top-controls').forEach(el => {
            el.style.display = '';
        });
    }

    updateTestInstructionsPosition();
}

function resetTest() {
    // Store the current difficulty before resetting
    const previousDifficulty = currentDifficulty || 'beginner';

    // Reset all test variables and UI
    timer = selectedTime;
    updateTimer();
    updateProgressBar(timer);
    // ... (reset other variables as needed)

    customTextBtn.classList.remove('selected');

    // Hide instructions and show buttons
    const buttonGroup = document.querySelector('.button-group');
    const instructions = document.getElementById('test-instructions');
    
    instructions.classList.remove('visible');
    setTimeout(() => {
        buttonGroup.classList.remove('hidden');
    }, 300); // Delay to allow instructions to hide first   

    // Re-enable UI elements
    enableUIElements();
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }

    currentDifficulty = null;

    // Set the difficulty back to what it was
    currentDifficulty = previousDifficulty;
    updateUIForDifficulty(currentDifficulty);

    // Re-enable UI elements
    enableUIElements();
    resetKeyboardBorder();

    // Reset the visualizer waves
    if (visualizer) {
        visualizer.resetWaves();
    }
}

    function startTest(isCustomTest = false) {
        let resultSaved = false;
    recentlyClosedProgressModal = false;

    waveVisualizerUnlocked = localStorage.getItem('waveVisualizerUnlocked') === 'true';
    document.getElementById('waveVisualizer').style.display = waveVisualizerUnlocked ? 'block' : 'none';
    document.querySelector('.visualizer-opacity-slider').style.display = waveVisualizerUnlocked ? 'flex' : 'none';

    if (visualizer) {
        const difficultyColor = isCustomTest ? '#34495e' : getDifficultyColor(currentDifficulty);
        visualizer.updateColor(difficultyColor);
    }

    if (isCustomTextSelected) {
        const customText = document.getElementById('custom-text-input').value.trim();
        if (customText.length === 0) {
            alert("Please enter some text before starting the custom test.");
            openCustomTextModal(); // Reopen the custom text modal
            return;
        }
    }
    
    if (testActive) {
        resetAndRestartTest();
        return;
    }

    if (isCustomTextSelected) {
        const customText = document.getElementById('custom-text-input').value.trim();
        if (customText.length === 0) {
            alert("Please enter some text before starting the custom test.");
            openCustomTextModal(); // Reopen the custom text modal
            return;
        }
    }
    
    if (testActive) {
        resetAndRestartTest();
        return;
    }

    if (!isCustomTest) {
        currentDifficulty = currentDifficulty || getCurrentDifficulty();
        if (!currentDifficulty) {
            alert('Please select a difficulty level before starting the test.');
            return;
        }
        setDifficulty(currentDifficulty);
    } else {
        currentDifficulty = 'custom';
    }
    
    if (!selectedTime) {
        alert('Please select a time duration for the test.');
        return;
    }

    

    // Handle word selection
    if (isCustomTest) {
        const addPunctuation = getPunctuationState();
        words = originalCustomText.split(/\s+/);
        if (addPunctuation) {
            words = addRandomPunctuation(words);
        }
    } else if (words.length === 0) {
        // Only reset words for non-custom tests if the array is empty
        resetWordList();
    }

    // Reset variables
    isTyping = true;
    typedCharacters = 0;
    typedWords = 0;
    correctWords = 0;
    totalWords = 0;
    correctKeystrokes = 0;
    incorrectKeystrokes = 0;
    totalKeystrokes = 0;
    wordErrors = {};
    resetHeatmap();
    lastInputTime = Date.now();
    wpmData = [];
    errorTimeStamps = [];
    totalWordTime = 0;
    wordCount = 0;
    wordStartTime = Date.now();
    currentWordIndex = 0;
    sessionProblematicWords = {};

    typingArea.textContent = ''; // Clear the instruction text
    displayWords();
    timer = selectedTime; // Reset the timer for the test
    testActive = true;
    timerStarted = false;
    input.disabled = false;
    input.value = '';
    input.focus();
    input.placeholder = "Type here.";
    startButton.textContent = 'Reset Test';
    startButton.title = 'Click to reset the test';
    input.selectionStart = input.selectionEnd = 0;

    // Set the initial color for the progress bar
    currentHighlightColor = getComputedStyle(document.documentElement).getPropertyValue(`--${currentDifficulty}-color`).trim();

    // Update progress bar initially
    updateProgressBar(timer);
    updateProgressBar(selectedTime);
    updateTimer(selectedTime);
    updateUIForTest(isCustomTest);

    const buttonGroup = document.querySelector('.button-group');
    const instructions = document.getElementById('test-instructions');
    document.body.classList.add('test-active');
    
    buttonGroup.classList.add('hidden');
    instructions.style.display = 'block';
    setTimeout(() => {
        instructions.classList.add('active');
    }, 10);

    // Disable UI elements when typing begins
    input.addEventListener('input', function onFirstInput() {
        disableUIElements();
        input.removeEventListener('input', onFirstInput);
    }, { once: true });

    testActive = true;
    document.querySelector('.slider-container').classList.add('test-active');

    // Ensure the first word is highlighted
    const currentWordElement = document.getElementById('current-word');
    if (currentWordElement) {
        currentWordElement.classList.remove('incorrect');
    }

    // Ensure the input field has the correct border
    if (currentDifficulty) {
        input.classList.add(`border-${currentDifficulty}`);
    }

    // Set up the event listener to start the timer when typing begins
    input.addEventListener('input', function onFirstInput() {
        testActive = true;
        startTyping();
        input.removeEventListener('input', onFirstInput);
    }, { once: true });

    let updateInterval = setInterval(updateAverageWordTime, 1000);

    // Clear any existing AFK timer
    clearInterval(afkInterval);
    clearTimeout(afkTimer);
}

function updateUIForTest(isCustomTest) {
    const color = isCustomTest ? '#34495e' : currentHighlightColor;

    const progressBar = document.getElementById('timer-progress-bar');
    if (progressBar) {
        progressBar.style.backgroundColor = color;
    }

    startButton.style.backgroundColor = color;
    startButton.style.color = 'white';

    const elementsToUpdate = [
        document.getElementById('typing-area'),
        document.getElementById('input'),
        document.getElementById('time-left'),
        document.getElementById('wpm-box'),
        document.getElementById('accuracy-box')
    ];
    
    elementsToUpdate.forEach(element => {
        if (element) {
            element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced', 'border-custom');
            if (isCustomTest) {
                element.classList.add('border-custom');
                element.style.borderColor = color;
            } else {
                element.classList.add(`border-${currentDifficulty}`);
                element.style.borderColor = color;
            }
        }
    });

    document.documentElement.style.setProperty('--highlight-color', color);
}


    function startTyping() {
        startTimerCountdown();
        startAfkTimer();
        resetAfkTimer(); // Start the AFK timer when typing begins
    }

    function updateUIForCurrentSettings() {
        // Update difficulty slider
        setDifficulty(currentDifficulty);

        // Update time selector
        const timeOptions = document.querySelectorAll('.time-option');
        timeOptions.forEach(option => {
            option.classList.remove('selected');
            if (parseInt(option.dataset.time) === selectedTime) {
                option.classList.add('selected');
            }
        });

        // Update time display
        updateTimeLeftDisplay(selectedTime);
    }





function startTimerCountdown() {
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    const startTime = Date.now();
    timerStarted = true;
    timerInterval = setInterval(() => {
        const elapsedTime = (Date.now() - startTime) / 1000;
        timer = Math.max(0, selectedTime - elapsedTime);
        updateTimer();
        updateProgressBar(timer);
        checkWaveVisualizerUnlock(); // Add this line
        if (timer <= 0) {
            clearInterval(timerInterval);
            endTest();
        }
    }, 1000); // Update every second
}

    function resetMainInterface() {
    const mainSliderHandle = document.querySelector('#difficultySlider .slider-handle');
    const mainSliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    const elementsToReset = [
        document.getElementById('typing-area'),
        document.getElementById('input'),
        document.getElementById('time-left'),
        document.getElementById('wpm-box'),
        document.getElementById('accuracy-box')
    ];

    // Don't reset the position or color if we have a lastUsedDifficulty
    if (lastUsedDifficulty) {
        let position, color;
        switch (lastUsedDifficulty) {
            case 'beginner':
                position = '0%';
                color = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
                break;
            case 'intermediate':
                position = '33.33%';
                color = getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim();
                break;
            case 'advanced':
                position = '66.66%';
                color = getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim();
                break;
            default:
                position = '0%';
                color = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
        }

        mainSliderHandle.style.left = position;
        mainSliderHandle.className = `slider-handle ${lastUsedDifficulty}`;
        mainSliderHandle.style.backgroundColor = color;

        // Update selected state for slider options
        mainSliderOptions.forEach((option, index) => {
            option.classList.toggle('selected', index === ['beginner', 'intermediate', 'advanced'].indexOf(lastUsedDifficulty));
            option.style.color = option.classList.contains('selected') ? 'white' : '';
        });
    } else {
        // If no lastUsedDifficulty, reset to default (beginner)
        mainSliderHandle.style.left = '0%';
        mainSliderHandle.className = 'slider-handle beginner';
        mainSliderHandle.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();

        mainSliderOptions.forEach((option, index) => {
            option.classList.toggle('selected', index === 0);
            option.style.color = index === 0 ? 'white' : '';
        });
    }

    // Reset border colors
    elementsToReset.forEach(element => {
        if (element) {
            element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced');
            element.style.borderColor = '';
        }
    });

    // Reset highlight color
    document.documentElement.style.setProperty('--highlight-color', '');

    // Reset progress bar color
    const progressBar = document.getElementById('timer-progress-bar');
    if (progressBar) {
        progressBar.style.backgroundColor = '#dddddd';
    }

    // Reset start button
    const startButton = document.getElementById('start-button');
    startButton.style.backgroundColor = '#dddddd';
    startButton.style.color = '#666666';
}

function lerp(start, end, amount) {
    return start + (end - start) * amount;
}

function checkWaveVisualizerUnlock() {
    console.log('Checking wave visualizer unlock...');
    if (waveVisualizerUnlocked) {
        console.log('Wave visualizer already unlocked');
        return;
    }

    const results = JSON.parse(localStorage.getItem('typingResults')) || [];
    const highAccuracyTests = results.filter(r => r.accuracy >= 90).length;

    console.log(`High accuracy tests: ${highAccuracyTests}`);

    if (highAccuracyTests >= 20) {
        console.log('Unlocking due to high accuracy tests');
        unlockWaveVisualizer();
        return;
    }

    if (testActive && (selectedTime === 300 || selectedTime === 600)) {
        const halfwayPoint = selectedTime / 2;
        const elapsedTime = selectedTime - timer;
        const accuracy = calculateAccuracy();

        console.log(`Test active: ${testActive}, Selected time: ${selectedTime}, Elapsed time: ${elapsedTime}, Halfway point: ${halfwayPoint}, Accuracy: ${accuracy}`);

        if (elapsedTime >= halfwayPoint && accuracy >= 90) {
            console.log('Unlocking due to mid-test high accuracy');
            unlockWaveVisualizer();
        }
    }
}

function initializeVisualizer() {
    const difficultyColor = getDifficultyColor(currentDifficulty);
    visualizer = new WaveVisualizer(difficultyColor);
}

function unlockWaveVisualizer() {
    console.log('Unlocking wave visualizer');
    waveVisualizerUnlocked = true;
    localStorage.setItem('waveVisualizerUnlocked', 'true');
    showActiveAchievement("Flow State Achieved!");
    const visualizerElement = document.getElementById('waveVisualizer');
    const opacitySlider = document.querySelector('.visualizer-opacity-slider');
    
    if (visualizerElement) {
        visualizerElement.style.display = 'block';
        console.log('Visualizer element displayed');
    } else {
        console.error('Visualizer element not found');
    }
    
    if (opacitySlider) {
        opacitySlider.style.display = 'flex';
        console.log('Opacity slider displayed');
    } else {
        console.error('Opacity slider not found');
    }

    if (!visualizer) {
        console.log('Creating new WaveVisualizer');
        visualizer = new WaveVisualizer();
        visualizer.animate();
    } else {
        console.log('WaveVisualizer already exists');
    }
}

function showActiveAchievement(title) {
    console.log('Showing active achievement:', title);
    const achievement = document.createElement('div');
    achievement.className = 'active-achievement';
    achievement.innerHTML = `
        <h3>${title}</h3>
        <p>üåü</p>
    `;
    document.body.appendChild(achievement);

    // Position the achievement in the top center
    achievement.style.position = 'fixed';
    achievement.style.top = '-100px';
    achievement.style.left = '50%';
    achievement.style.transform = 'translateX(-50%)';

    // Force a reflow before adding the 'show' class
    achievement.offsetHeight;

    setTimeout(() => {
        achievement.style.top = '20px';
        achievement.classList.add('show');
    }, 10);

    setTimeout(() => {
        achievement.style.top = '-100px';
        achievement.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(achievement);
        }, 500);
    }, 3000);
}

function saveOpacitySliderPosition() {
    const opacitySlider = document.getElementById('opacitySlider');
    localStorage.setItem('visualizerOpacity', opacitySlider.value);
}

function loadOpacitySliderPosition() {
    const opacitySlider = document.getElementById('opacitySlider');
    const savedOpacity = localStorage.getItem('visualizerOpacity');
    if (savedOpacity) {
        opacitySlider.value = savedOpacity;
        updateVisualizerOpacity(savedOpacity);
    }
}

// Call this function when the page loads
loadOpacitySliderPosition();

// Add this to your existing opacity slider event listener
opacitySlider.addEventListener('input', function() {
    const opacity = this.value;
    updateVisualizerOpacity(opacity);
    saveOpacitySliderPosition();
});

function calculateWPM() {
    const elapsedMinutes = (Date.now() - startTime) / 60000;
    return Math.round(correctWords / elapsedMinutes);
}
class WaveVisualizer {
    constructor(color) {
        this.canvas = document.getElementById('waveVisualizer');
        this.ctx = this.canvas.getContext('2d');
        this.color = color || '#34495e'; // Default color if none provided
        this.waves = [];
        this.waveCount = 3;
        this.baseSpeed = 0.005;
        this.targetSpeed = 0.005;
        this.currentSpeed = 0.005;
        this.baseAmplitude = 20;
        this.targetAmplitude = 20;
        this.currentAmplitude = 20;
        this.basePeriod = 0.01;
        this.lastWordTime = null;
        this.lastUpdateTime = Date.now();
        this.dampingFactor = 0.1;

        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        for (let i = 0; i < this.waveCount; i++) {
            this.waves.push({
                y: this.canvas.height / 2,
                length: this.canvas.width + 20,
                amplitude: this.baseAmplitude * (i + 1) * 0.5,
                period: this.basePeriod / (i + 1),
                phase: 0
            });
        }

        this.animate();
    }

    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    updatePerformance(wordSubmitTime, isCorrectWord) {
        const now = Date.now();
        const timeSinceLastWord = this.lastWordTime ? (now - this.lastWordTime) / 1000 : 0;

        if (isCorrectWord) {
            if (timeSinceLastWord <= 1) {
                this.targetSpeed = Math.min(this.targetSpeed * 1.1, 0.05);
            } else {
                this.targetSpeed = Math.max(0.005, this.targetSpeed * 0.9);
            }
            this.targetAmplitude += 2;
        } else {
            this.targetSpeed = Math.max(0.005, this.targetSpeed * 0.9);
            this.targetAmplitude = Math.max(this.baseAmplitude, this.targetAmplitude - 2);
        }

        this.lastWordTime = now;
    }

    resetWaves() {
        this.targetSpeed = 0.005;
        this.currentSpeed = 0.005;
        this.targetAmplitude = 20;
        this.currentAmplitude = 20;
    }

    updateColor(newColor) {
        this.color = newColor;
    }

    hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `${r}, ${g}, ${b}`;
        
    }

    animate() {
        const now = Date.now();
        const delta = now - this.lastUpdateTime;

        this.currentSpeed += (this.targetSpeed - this.currentSpeed) * this.dampingFactor;
        this.currentAmplitude += (this.targetAmplitude - this.currentAmplitude) * this.dampingFactor;

        if (delta > 1000 / 30) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            const time = now * this.currentSpeed;

            this.waves.forEach((wave, index) => {
                wave.phase += this.currentSpeed;

                this.ctx.beginPath();
                this.ctx.moveTo(0, wave.y);
                wave.amplitude = this.currentAmplitude * (index + 1) * 0.5;

                for (let x = 0; x < this.canvas.width; x++) {
                    const dx = x * wave.period;
                    const y = wave.y + Math.sin(dx + wave.phase) * wave.amplitude;
                    this.ctx.lineTo(x, y);
                }

                this.ctx.strokeStyle = `rgba(${this.hexToRgb(this.color)}, ${0.1 + index * 0.1})`;
                this.ctx.lineWidth = 2 + index;
                this.ctx.stroke();
            });

            this.lastUpdateTime = now;
        }

        requestAnimationFrame(() => this.animate());
    }
}



function hexToRgb(hex) {
  // Remove the leading '#' from the hex code
  hex = hex.replace('#', '');

  // Check if the input is a valid hex color code
  if (!/^[0-9a-f]{6}|[0-9a-f]{3}$/i.test(hex)) {
    return { r: 0, g: 0, b: 0 };
  }

  // Convert the hex code to RGB
  const result = /^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(hex);
  if (result) {
    const r = parseInt(result[1], 16);
    const g = parseInt(result[2], 16);
    const b = parseInt(result[3], 16);
    return { r, g, b };
  }

  // Return a default RGB object if the input is invalid
  return { r: 0, g: 0, b: 0 };
}




function updateUIForDifficulty(level) {
    const elementsToUpdate = [
        document.getElementById('typing-area'),
        document.getElementById('input'),
        document.getElementById('time-left'),
        document.getElementById('wpm-box'),
        document.getElementById('accuracy-box')
    ];
    
    const color = getComputedStyle(document.documentElement).getPropertyValue(`--${level}-color`).trim();

    elementsToUpdate.forEach(element => {
        if (element) {
            element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced');
            element.classList.add(`border-${level}`);
            element.style.borderColor = color;
        }
    });

    // Update the wave visualizer color
    if (visualizer) {
        visualizer.updateColor(color);
    }

    // Update slider position and color
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    if (sliderHandle && sliderOptions.length === 3) {
        let position;
        let index;
        switch (level) {
            case 'beginner':
                position = '0%';
                index = 0;
                break;
            case 'intermediate':
                position = '33.33%';
                index = 1;
                break;
            case 'advanced':
                position = '66.66%';
                index = 2;
                break;
            default:
                position = '0%';
                index = 0;
        }
        sliderHandle.style.left = position;
        sliderHandle.className = `slider-handle ${level}`;
        sliderHandle.style.backgroundColor = color;

        sliderOptions.forEach((option, i) => {
            option.classList.toggle('selected', i === index);
            option.style.color = i === index ? 'white' : '';
        });
    }

    // Update global variables
    currentHighlightColor = color;
    document.documentElement.style.setProperty('--highlight-color', color);

    // Update start button
    updateStartButtonStyle();
}


    function resetUIAfterTest() {
        document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('selected'));
        updateStartButtonStyle(); // Update start button based on current difficulty
        startButton.textContent = 'Start Test';

        typingArea.innerHTML = 'Select a difficulty and click \'Start Test\' to begin';
        input.value = '';
        input.placeholder = "Let's get typing...";

        const elementsToReset = [
            document.getElementById('typing-area'),
            document.getElementById('input'),
            document.getElementById('time-left'),
            document.getElementById('wpm-box'),
            document.getElementById('accuracy-box')
        ];
        
        elementsToReset.forEach(element => {
            if (element) {
                element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced', 'border-custom');
            }
        });

        resetProgressBar();

        // Reset the keyboard border
        resetKeyboardBorder();

        updateUIForDifficulty(lastUsedDifficulty);
    }

    function resetProgressBar() {
        const progressBar = document.getElementById('timer-progress-bar');
        progressBar.style.width = '100%';
        progressBar.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(`--${currentDifficulty}-color`).trim();
    }

    function updateAverageWordTime(isNewWord = false) {
        const currentTime = Date.now();
        
        if (isNewWord) {
            if (wordStartTime) {
            const wordTime = (currentTime - wordStartTime) / 1000; // Convert to seconds
            totalWordTime += wordTime;
            wordCount++;
            }
            wordStartTime = currentTime;
        }
        
        if (wordCount > 0) {
            const avgTime = totalWordTime / wordCount;
            document.getElementById('avg-word-time').textContent = `Avg. Word Time: ${avgTime.toFixed(1)}s`;
        }
        }


        function updateStats() {
            const elapsedTime = (new Date() - startTime) / 1000 / 60; // in minutes
            const wpm = elapsedTime > 0 ? Math.round(correctWords / elapsedTime) : 0;
            const accuracy = calculateAccuracy();
            const wordAccuracy = totalWords > 0 ? Math.round((correctWords / totalWords) * 100) : 100;
            const keystrokeAccuracy = totalKeystrokes > 0 ? Math.round((correctKeystrokes / totalKeystrokes) * 100) : 100;

            wpmDisplay.textContent = wpm;
            accuracyDisplay.textContent = `${accuracy}%`;
            document.getElementById('word-accuracy').innerText = `Word: ${wordAccuracy}%`;
            document.getElementById('key-accuracy').innerText = `Key: ${keystrokeAccuracy}%`;

            // Add this line to check for flow state achievement
            checkWaveVisualizerUnlock();
        }


    function calculateAccuracy() {
        const wordAccuracy = totalWords > 0 ? (correctWords / totalWords) * 100 : 100;
        const totalKeystrokesWithoutSpaces = totalKeystrokes - words.join(' ').length + words.length;
        const keystrokeAccuracy = totalKeystrokesWithoutSpaces > 0 ? (correctKeystrokes / totalKeystrokesWithoutSpaces) * 100 : 100;
        
        if (totalKeystrokesWithoutSpaces === 0) {
            return 100;
        }
        
        const overallAccuracy = (wordAccuracy + keystrokeAccuracy) / 2;
        
        return Math.round(overallAccuracy);
    }

    function createPerformanceChart(difficultyColor, isDarkMode) {
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const textColor = isDarkMode ? '#f0f0f0' : '#333';
        
        const chartData = {
            labels: wpmData.map(data => data.time.toFixed(0)),
            datasets: [
                {
                    label: 'WPM',
                    data: wpmData.map(data => ({x: data.time, y: data.wpm})),
                    borderColor: difficultyColor,
                    backgroundColor: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                    fill: false,
                    tension: 0.1,
                    order: 2  // This ensures the line is drawn first (underneath)
                },
                {
                    label: 'Errors',
                    data: errorTimeStamps.map(error => ({
                        x: error.time,
                        y: error.wpm,
                        errorWord: error.errorWord,
                        correctWord: error.correctWord
                    })),
                    backgroundColor: 'red',
                    borderColor: 'red',
                    pointStyle: 'crossRot',
                    radius: 6,
                    pointHoverRadius: 8,
                    showLine: false,
                    order: 1  // This ensures the points are drawn last (on top)
                }
            ]
        };

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    title: {
                        display: true,
                        text: 'Time (seconds)',
                        color: textColor
                    },
                    ticks: {
                        color: textColor
                    },
                    grid: {
                        color: gridColor
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'WPM',
                        color: textColor
                    },
                    ticks: {
                        color: textColor
                    },
                    grid: {
                        color: gridColor
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.dataset.label === 'Errors') {
                                const errorData = context.raw;
                                return [
                                    `Time: ${errorData.x.toFixed(1)}s`,
                                    `WPM: ${errorData.y}`,
                                    `Typed: "${errorData.errorWord}"`,
                                    `Correct: "${errorData.correctWord}"`
                                ];
                            }
                            return `WPM: ${context.parsed.y}`;
                        }
                    },
                    backgroundColor: isDarkMode ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)',
                    titleColor: isDarkMode ? '#fff' : '#000',
                    bodyColor: isDarkMode ? '#fff' : '#000'
                }
            }
        };

        // Add a custom plugin to display a message when there's no data
        const noDataPlugin = {
            id: 'noDataPlugin',
            afterDraw: (chart) => {
                if (chart.data.datasets[0].data.length === 0) {
                    const { ctx, chartArea: { left, top, width, height } } = chart;
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = '16px Arial';
                    ctx.fillStyle = textColor;
                    ctx.fillText('No data available. Complete a test to see your performance chart.', left + width / 2, top + height / 2);
                    ctx.restore();
                }
            }
        };

        chartOptions.plugins.noDataPlugin = noDataPlugin;

        new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: chartOptions,
            plugins: [noDataPlugin]
        });
    }

    function showResultsModal(dataPoint) {
    const resultContent = document.getElementById('result-content');
    const resultsModal = document.getElementById('results');
    const progressModal = document.getElementById('progressModal');
    const wpm = dataPoint.y;
    const accuracy = dataPoint.accuracy;
    const correctWords = dataPoint.correctWords;
    const totalWords = dataPoint.totalWords;
    const keystrokeAccuracy = dataPoint.keystrokeAccuracy;
    const duration = dataPoint.duration;

    const encouragementMsg = getEncouragementMessage(wpm, accuracy);
    const difficultyColor = getDifficultyColor(dataPoint.difficulty);
    const difficultyName = getDifficultyName(dataPoint.difficulty);
    const isDarkMode = document.body.classList.contains('dark-mode');

    resultContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="font-size: 32px; margin-bottom: 15px;">Your <span style="color: ${difficultyColor};">${difficultyName}</span> Results</h2>
            <p style="font-size: 20px;">${encouragementMsg}</p>
        </div>
        <div style="display: flex; justify-content: center; gap: 200px; margin-bottom: 30px;">
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${wpm.toFixed(2)}</h3>
                <p style="font-size: 18px; opacity: 0.8;">Words Per Minute</p>
            </div>
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${accuracy.toFixed(2)}%</h3>
                <p style="font-size: 18px; opacity: 0.8;">Overall Accuracy</p>
            </div>
        </div>
        <div style="background-color: rgba(200, 200, 200, 0.5); border-radius: 8px; padding: 20px; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h4 style="text-align: center; margin-top: 0; margin-bottom: 15px; font-size: 22px;">
                Test Duration: <span style="color: ${difficultyColor};">${duration} seconds</span>
            </h4>
            <div style="display: flex; justify-content: space-between;">
                <div style="flex: 1; padding-right: 20px; border-right: 1px solid #999;">
                    <p><strong>Correct Words:</strong> ${correctWords} / ${totalWords}</p>
                    <p><strong>Word Accuracy:</strong> ${((correctWords / totalWords) * 100).toFixed(2)}%</p>
                </div>
                <div style="flex: 1; padding-left: 20px;">
                    <p><strong>Keystroke Accuracy:</strong> ${keystrokeAccuracy.toFixed(2)}%</p>
                </div>
            </div>
        </div>
    `;

    showModal('results');

    // Set a higher z-index for the results modal
    resultsModal.style.zIndex = '1001';  // Ensure this is higher than the progress modal's z-index

    // Show the results modal
    resultsModal.style.display = 'flex';

}


function saveResult() {
    console.log('saveResult called at:', new Date().toISOString());
    console.log('Saving result for difficulty:', currentDifficulty);
    clearInterval(timerInterval);
    testActive = false;
    timerStarted = false;
    input.disabled = true;
    startButton.textContent = 'Start Test';
    startButton.title = "Please select a difficulty level before starting the test";
    
    const wpm = parseInt(wpmDisplay.textContent);
    const accuracy = calculateAccuracy();
    const totalKeystrokes = correctKeystrokes + incorrectKeystrokes;
    const wordAccuracy = Math.round((correctWords / totalWords) * 100);
    const keystrokeAccuracy = Math.round((correctKeystrokes / totalKeystrokes) * 100);

    const result = {
        date: new Date().toISOString(),
        wpm: wpm,
        accuracy: accuracy,
        wordAccuracy: wordAccuracy,
        keystrokeAccuracy: keystrokeAccuracy,
        difficulty: currentDifficulty,
        correctWords: correctWords,
        totalWords: totalWords,
        correctKeystrokes: correctKeystrokes,
        incorrectKeystrokes: incorrectKeystrokes,
        duration: selectedTime
    };

    resultSaved = true;

    // Only save results and update word error tracker if it's not a custom test
    if (currentDifficulty !== 'custom') {
        let results = JSON.parse(localStorage.getItem('typingResults')) || [];
        results.push(result);
        
        // Sort results by date, most recent first
        results.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Keep only the last week of data or MAX_TESTS, whichever is less
        const ONE_WEEK = 7 * 24 * 60 * 60 * 1000; // One week in milliseconds
        const MAX_TESTS = 100;
        const oneWeekAgo = Date.now() - ONE_WEEK;
        results = results.filter((r, index) => 
            new Date(r.date) > oneWeekAgo && index < MAX_TESTS
        );

        localStorage.setItem('typingResults', JSON.stringify(results));

        resetLastKnownValues();

        // Update word error tracker
        for (const [word, data] of Object.entries(sessionProblematicWords)) {
            if (!wordErrorTracker[word]) {
                wordErrorTracker[word] = { errors: 0, total: 0, totalTime: 0, totalKeystrokes: 0, difficulty: currentDifficulty };
            }
            wordErrorTracker[word].errors += data.errors;
            wordErrorTracker[word].total += data.total;
            wordErrorTracker[word].totalTime += data.totalTime;
            wordErrorTracker[word].totalKeystrokes += data.totalKeystrokes;
            wordErrorTracker[word].lastUpdated = Date.now();
        }

        localStorage.setItem('wordErrorTracker', JSON.stringify(wordErrorTracker));
    }

    const avgWordTime = totalWordTime > 0 ? (totalWordTime / wordCount).toFixed(2) : '0.00';
    const encouragementMsg = getEncouragementMessage(wpm, accuracy);
    const difficultyColor = getDifficultyColor(currentDifficulty);
    const difficultyName = getDifficultyName(currentDifficulty);
    const isDarkMode = document.body.classList.contains('dark-mode');

    const sessionProblematicWordsList = getSessionProblematicWords().join(', ');
    resultContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="font-size: 32px; margin-bottom: 15px;">Your <span style="color: ${difficultyColor};">${difficultyName}</span> Results</h2>
            <p style="font-size: 20px;">${encouragementMsg}</p>
        </div>
        <div style="display: flex; justify-content: center; gap: 200px; margin-bottom: 30px;">
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${wpm}</h3>
                <p style="font-size: 18px; opacity: 0.8;">Words Per Minute</p>
            </div>
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${accuracy}%</h3>
                <p style="font-size: 18px; opacity: 0.8;">Overall Accuracy</p>
            </div>
        </div>
        <div style="background-color: rgba(200, 200, 200, 0.5); border-radius: 8px; padding: 20px; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h4 style="text-align: center; margin-top: 0; margin-bottom: 15px; font-size: 22px;">
                Test Duration: <span style="color: ${difficultyColor};">${selectedTime} seconds</span>
            </h4>
            <div style="display: flex; justify-content: space-between;">
                <div style="flex: 1; padding-right: 20px; border-right: 1px solid #999;">
                    <p><strong>Correct Words:</strong> ${correctWords} / ${totalWords}</p>
                    <p><strong>Word Accuracy:</strong> ${wordAccuracy}%</p>
                    <p><strong>Avg. Word Time:</strong> ${avgWordTime}s</p>
                </div>
                <div style="flex: 1; padding-left: 20px;">
                    <p><strong>Keystrokes:</strong> ${totalKeystrokes} (<span style="color: #4CAF50;">${correctKeystrokes}</span> | <span style="color: #f44336;">${incorrectKeystrokes}</span>)</p>
                    <p><strong>Keystroke Accuracy:</strong> ${keystrokeAccuracy}%</p>
                </div>
            </div>
        </div>
        <div id="problematic-words-container" style="background-color: rgba(200, 200, 200, 0.5); border-radius: 8px; padding: 20px; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h4 style="margin-top: 0; margin-bottom: 10px;">Challenging Words (This Session):</h4>
            <p id="problematic-words-list-session" style="margin: 0;">${sessionProblematicWordsList || 'None'}</p>
        </div>
        <div style="width: 100%; max-width: 900px; height: 350px; margin-bottom: 30px; margin-left: auto; margin-right: auto;">
            <canvas id="performance-chart"></canvas>
        </div>
        <div style="text-align: center;">
            <button id="share-results-button" class="${currentDifficulty}" onclick="shareResults()">Save Results</button>
        </div>
    `;

    createPerformanceChart(difficultyColor, isDarkMode);

    // Ensure the button gets the correct style after it's added to the DOM
    const shareButton = document.getElementById('share-results-button');
    if (shareButton) {
        shareButton.className = '';  // Clear existing classes
        shareButton.classList.add(currentDifficulty);  // Add the current difficulty class
    }

    updateProblematicWordsDisplay();
}


   // This Prevents people from saving the code for personal use!!!!
    document.addEventListener('keydown', function(event) {
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            alert('Saving the page is disabled.');
        }
    });






    function finalizeTest() {
    clearInterval(timerInterval);
    clearInterval(afkInterval);
    testActive = false;
    timerStarted = false;
    input.disabled = true;
    
    // Reset UI elements
    startButton.textContent = 'Start Test';
    startButton.title = "Please select a difficulty level before starting the test";
    
    // Disable test-specific UI elements
    disableUIElements();
    
    document.body.classList.remove('test-active');
    document.querySelector('.slider-container').classList.remove('test-active');
    
    // Reset the keyboard border
    resetKeyboardBorder();
}





    input.addEventListener('input', resetAfkTimer);

    input.addEventListener('input', (e) => {
    if (testActive) {
        // Reset AFK timer
        resetAfkTimer();

        if (!timerStarted) {
            startTime = new Date();
            startTimerCountdown();
        }

        const typedWord = e.target.value.trim();
        const currentWord = words[currentWordIndex];
        const currentWordElement = document.getElementById('current-word');

        const isCorrect = currentWord.startsWith(typedWord);
        currentWordElement.classList.toggle('incorrect', !isCorrect);

        // Update heatmap for the last typed character
        if (e.inputType === 'insertText' && e.data) {
            updateHeatmap(e.data.toLowerCase(), isCorrect);
        } else if (e.inputType === 'deleteContentBackward') {
            updateHeatmap('backspace', true); // Always consider backspace as correct
        }

        // Record WPM data every second
        const currentTime = (Date.now() - startTime) / 1000;
        if (Math.floor(currentTime) > wpmData.length) {
            const elapsedTimeInMinutes = currentTime / 60;
            const currentWpm = Math.round(correctWords / elapsedTimeInMinutes);
            wpmData.push({ time: currentTime, wpm: currentWpm });
        }

        if (!isCorrect || (e.data === ' ' && !checkWord(typedWord, currentWord))) {
            errorTimeStamps.push({
                time: (Date.now() - startTime) / 1000,
                wpm: Math.round(correctWords / ((Date.now() - startTime) / 60000)),
                errorWord: typedWord,
                correctWord: currentWord
            });
        }

        if (e.data === ' ' || e.inputType === 'insertLineBreak') {
            const isCorrect = checkWord(typedWord, currentWord);
            if (isCorrect) {
                correctWords++;
                visualizer.updatePerformance(calculateWPM(), calculateAccuracy(), true);
            } else {
                visualizer.updatePerformance(calculateWPM(), calculateAccuracy(), false);
            }

            // Handle word completion
            const wordTime = (Date.now() - wordStartTime) / 1000;
            const isError = !checkWord(typedWord, currentWord);

            if (!sessionProblematicWords[currentWord]) {
                sessionProblematicWords[currentWord] = {
                    errors: 0,
                    total: 0,
                    totalTime: 0,
                    totalKeystrokes: 0
                };
            }
            sessionProblematicWords[currentWord].errors += isError ? 1 : 0;
            sessionProblematicWords[currentWord].total += 1;
            sessionProblematicWords[currentWord].totalTime += wordTime;
            sessionProblematicWords[currentWord].totalKeystrokes += currentWordKeystrokes;

            totalWords++;
            currentWordIndex++;
            e.target.value = '';

            updateAverageWordTime(true);

            currentWordKeystrokes = 0;
            currentWordCorrectKeystrokes = 0;
            wordStartTime = Date.now();

            if (currentDifficulty === 'custom') {
                if (currentWordIndex >= words.length) {
                    // Reset to the beginning of the custom text
                    currentWordIndex = 0;
                    words = originalCustomText.split(/\s+/);
                    if (getPunctuationState()) {
                        words = addRandomPunctuation(words);
                    }
                }
            }

            displayWords(); // This will handle displaying words without refilling
        }

        // Count keystrokes
        if (e.inputType === 'insertText') {
            currentWordKeystrokes++;
            totalKeystrokes++;
            if (e.data !== ' ') {  // Exclude space from accuracy calculation
                if (isCorrect) {
                    currentWordCorrectKeystrokes++;
                    correctKeystrokes++;
                } else {
                    incorrectKeystrokes++;
                    // Update heatmap only for incorrect keystrokes
                    const char = e.data.toLowerCase();
                    updateHeatmap(char);
                }
            } else {
                // If it's a space, don't count it for accuracy, but do count it for total keystrokes
                currentWordCorrectKeystrokes++;  // Consider space as correct for the current word
                correctKeystrokes++;  // Consider space as correct overall
            }
        } else if (e.inputType === 'deleteContentBackward') {
            if (currentWordKeystrokes > 0) {
                currentWordKeystrokes--;
                totalKeystrokes--;
            }
            if (currentWordCorrectKeystrokes > 0) {
                currentWordCorrectKeystrokes--;
                correctKeystrokes--;
            }
            incorrectKeystrokes++;

            // Update heatmap for backspace
            updateHeatmap('backspace');
        }

        // Update stats after each input
        updateStats();

       // End test logic
    if (timer <= 0) {
        endTest();
    }
    }
});

    


function checkWord(typedWord, currentWord) {
    const isCorrect = typedWord === currentWord;
    const wpm = calculateWPM();
    const accuracy = calculateAccuracy();
    
        // Remove trailing punctuation for comparison
        const trimmedTypedWord = typedWord.replace(/[.,;:!?]$/, '');
        const trimmedCurrentWord = currentWord.replace(/[.,;:!?]$/, '');

        if (trimmedTypedWord === trimmedCurrentWord) {
            // If the words match without punctuation, check if punctuation was correct (if present)
            return typedWord === currentWord;
        }
        return false;
    }

    function updatePlatformInstructions() {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const instructions = document.getElementById('test-instructions');
        const controlKey = isMac ? '‚åò' : 'Ctrl';
        instructions.textContent = `Press ${isMac ? 'Return' : 'Enter'} to reset the test. Press ESC to cancel.`;
    }

    // Call resetAfkTimer on each keypress to reset the AFK timer
    input.addEventListener('keydown', resetAfkTimer);


    function initializeKeyboard() {
        const container = document.getElementById('keyboard-container');
        container.innerHTML = '';

        const layout = layouts[keyboardLayout];

        // Define the rows based on the keyboard layout
        const rows = [
            layout.slice(0, 14),
            layout.slice(14, 28),
            layout.slice(28, 41),
            layout.slice(41, 53),
            layout.slice(53, 63),
            layout.slice(63)
        ];

        rows.forEach(row => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'keyboard-row';

            row.forEach(key => {
                const keyElement = document.createElement('div');
                keyElement.className = 'key';
                keyElement.textContent = key;
                keyElement.id = `key-${key.toLowerCase().replace(/\s/g, '-')}`;

                // Special styling for specific keys
                if (key === 'Space') {
                    keyElement.classList.add('space');
                } else if (['Backspace', 'Enter', 'Shift'].includes(key)) {
                    keyElement.classList.add('wide');
                } else if (['Tab', 'CapsLock'].includes(key)) {
                    keyElement.classList.add('extra-wide');
                }

                rowDiv.appendChild(keyElement);
            });
            container.appendChild(rowDiv);
        });

        console.log('Keyboard initialized');
        
        // Apply current difficulty colors if a difficulty is selected
        if (currentDifficulty) {
            updateKeyBorderColors(currentHighlightColor);
        } else {
            resetHeatmap();
        }
        
        updateHeatmap();
    }

    

    

    function updateHeatmap(key, isCorrect) {
    if (key) {
        const keyElement = document.getElementById(`key-${key}`);
        if (keyElement) {
            const originalColor = keyElement.style.backgroundColor;
            
            // Get the current difficulty color
            const lightUpColor = getLightUpColor();
            
            // Light up the key
            keyElement.style.backgroundColor = lightUpColor;
            keyElement.style.boxShadow = `0 0 10px ${lightUpColor}`;
            
            // Reset the key after a short delay
            setTimeout(() => {
                if (!isCorrect) {
                    // For incorrect keys, apply the original heat map logic
                    keyPressCount[key] = (keyPressCount[key] || 0) + 1;
                    const intensity = Math.min(keyPressCount[key] / MAX_INTENSITY, 1);
                    const heatColor = getHeatColor(intensity);
                    keyElement.style.backgroundColor = heatColor;
                } else {
                    keyElement.style.backgroundColor = originalColor;
                }
                keyElement.style.boxShadow = '';
            }, 100);
        }
    }
}

function getLightUpColor() {
    let color;
    switch(currentDifficulty) {
        case 'beginner':
            color = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
            break;
        case 'intermediate':
            color = getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim();
            break;
        case 'advanced':
            color = getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim();
            break;
        case 'custom':
            color = '#34495e'; // The color you're using for custom tests
            break;
        default:
            color = '#a0f0a0'; // Default light green if no difficulty is set
    }

    // Convert the color to rgba with reduced opacity
    return convertToRGBA(color, 0.3); // Adjust the 0.3 value to increase or decrease opacity
}

function convertToRGBA(hex, opacity) {
    // Remove the hash if it's there
    hex = hex.replace('#', '');

    // Convert hex to RGB
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    // Return rgba color with specified opacity
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
}
        
    


function updateCursorPosition() {
    const cursorPosition = this.selectionStart;
    const text = this.value.substring(0, cursorPosition);
    const textWidth = getTextWidth(text, getComputedStyle(this).font);
    this.style.setProperty('--cursor-left', `${textWidth}px`);
    this.style.setProperty('--cursor-position', `${cursorPosition}ch`);
}

function getTextWidth(text, font) {
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
    const context = canvas.getContext('2d');
    context.font = font;
    return context.measureText(text).width;
}

    

function resetKeyboardBorder() {
    document.querySelectorAll('.key').forEach(key => {
        key.style.borderColor = ''; // Reset the border color
    });
}

function resetAndRestartTest() {
    // Store the current difficulty
    const previousDifficulty = currentDifficulty;

    // Reset test variables
    clearInterval(timerInterval);
    clearInterval(afkInterval);
    testActive = false;
    timerStarted = false;
    timer = selectedTime;
    currentWordIndex = 0;
    correctWords = 0;
    totalWords = 0;
    correctKeystrokes = 0;
    incorrectKeystrokes = 0;
    totalKeystrokes = 0;
    sessionProblematicWords = {};

    const instructions = document.getElementById('test-instructions');
    instructions.classList.add('active');
    updateTestInstructionsPosition();
    removeDifficultyGlow();
    
    // Reset UI
    updateTimer();
    updateProgressBar(timer);
    wpmDisplay.textContent = '0';
    accuracyDisplay.textContent = '100%';
    input.value = '';
    input.disabled = false;
    input.focus();

   // Handle word resetting based on stored difficulty
   if (previousDifficulty === 'custom' && originalCustomText) {
        words = originalCustomText.split(/\s+/);
        const addPunctuation = document.getElementById('add-punctuation-checkbox').checked;
        if (addPunctuation) {
            words = addRandomPunctuation(words);
        }
    } else {
        words = shuffleWords(getCurrentDifficultyWords(previousDifficulty));
    }
    
    currentWordIndex = 0;
    displayWords();

    // Reset and restart the test with the stored difficulty
    currentDifficulty = previousDifficulty;
    startTest(previousDifficulty === 'custom');

    // Update UI for the current difficulty
    updateUIForDifficulty(currentDifficulty);
}

function getCurrentDifficultyWords() {
    switch(currentDifficulty) {
        case 'beginner':
            return beginnerWords;
        case 'intermediate':
            return intermediateWords;
        case 'advanced':
            return advancedWords;
        default:
            return beginnerWords; // Default to beginner if somehow no difficulty is set
    }
}


function endTest() {
    console.log('Ending test.');
    clearInterval(timerInterval);
    clearInterval(afkInterval);
    testActive = false;
    timerStarted = false;
    input.disabled = true;
    if (visualizer) {
        visualizer.resetWaves();
    }

    // Store the last used difficulty
    lastUsedDifficulty = currentDifficulty;

    // Final update of stats
    updateStats(true);

    if (currentDifficulty === 'custom') {
        showCustomTestResult();
    } else {
        saveResult();
        let latestResult = {
            wpm: parseInt(wpmDisplay.textContent),
            accuracy: calculateAccuracy(),
            difficulty: currentDifficulty,
            totalWords: totalWords,
            correctWords: correctWords
        };
        updateAchievements(latestResult);
    }

    console.log('Showing results modal.');
    showModal('results');

    console.log('Resetting UI.');
    resetUIAfterTest();
    resetAfkTimer();
    enableUIElements();

    // Show buttons and hide instructions
    const buttonGroup = document.querySelector('.button-group');
    const instructions = document.getElementById('test-instructions');
    document.body.classList.remove('test-active');

    testActive = false;
    document.querySelector('.slider-container').classList.remove('test-active');
    
    switch (currentDifficulty) {
                case 'beginner':
                    updateDifficulty(0, 'beginner');
                    break;
                case 'intermediate':
                    updateDifficulty(33.33, 'intermediate');
                    break;
                case 'advanced':
                    updateDifficulty(66.66, 'advanced');
                    break;
            }
    
    instructions.classList.remove('active');
    setTimeout(() => {
        instructions.style.display = 'none';
        buttonGroup.classList.remove('hidden');
    }, 300); // Wait for the fade-out animation to complete

    // Reset variables
    words = [];

    // Update start button style based on current difficulty
    if (currentDifficulty) {
        startButton.style.backgroundColor = currentHighlightColor;
        startButton.style.color = 'white';
    } else {
        startButton.style.backgroundColor = '#dddddd';
        startButton.style.color = '#666666';
    }

    // Clear the typing area and reset placeholder
    typingArea.innerHTML = 'Select a difficulty and click \'Start Test\' to begin';
    input.value = '';
    input.placeholder = "Let's get typing.";
    input.classList.remove('border-beginner', 'border-intermediate', 'border-advanced');

    clearBorders();
    // Update UI to reflect current settings
    updateUIForCurrentSettings();

    // Enable the start button and update its text
    startButton.disabled = false;
    startButton.textContent = 'Start Test';
    clearInterval(updateInterval);

    
    setDifficulty(lastUsedDifficulty);

}

function handleStartReset() {
    if (testActive) {
        startButton.textContent = 'Reset Test';
        resetAndRestartTest();
    } else {
        startButton.textContent = 'Start Test';
        ensureDifficultySelected();
        updateDifficultyUI(currentDifficulty);
        if (currentDifficulty === 'custom') {
            startCustomTextTest();
        } else {
            startTest();
        }
    }
    removeDifficultyGlow();
}

function isAnyModalOpen() {
    const modals = document.querySelectorAll('.modal');
    for (let modal of modals) {
        if (modal.style.display === 'flex' || modal.style.display === 'block') {
            return true;
        }
    }
    return false;
}

function updateStartButtonStyle() {
    const isDarkMode = document.body.classList.contains('dark-mode');
    if (currentDifficulty) {
        startButton.style.backgroundColor = currentHighlightColor;
        startButton.style.color = 'white';
    } else {
        startButton.style.backgroundColor = isDarkMode ? '#444444' : '#dddddd';
        startButton.style.color = isDarkMode ? '#ffffff' : '#666666';
    }
}

document.addEventListener('keydown', function(event) {
    if (event.key === 'Enter' && !testActive && !isProgressModalOpen) {
        event.preventDefault();
        if (currentDifficulty === 'beginner' || !currentDifficulty) {
            setDifficulty('beginner');
            updateDifficultyUI('beginner');
            updateUIForDifficulty('beginner');
            startTest();
        }
    }
});

startButton.addEventListener('click', handleStartReset);

    startButton.addEventListener('click', () => {
        if (testActive) {
            // If a test is already active, reset it
            clearInterval(timerInterval);
            clearInterval(afkInterval);
            testActive = false;
            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '100%';
            testActive = false;
            timer = 60;
            updateTimer();
            updateProgressBar(timer);
            resetAfkTimer();


            resetHeatmap();
            enableUIElements();
        }
        checkDifficulty();
        startTest();
    });

    

    function drawProgressChart(results, timeRange, difficulty) {
    const ctx = document.getElementById('progress-chart').getContext('2d');

    // Helper function to capitalize first letter
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    // Helper function to get difficulty color
    function getDifficultyColor(difficultyLevel) {
        return difficultyColors[difficultyLevel] || difficultyColors['all'];
    }

    if (window.progressChart) {
        window.progressChart.destroy();
    }

    const isDarkMode = document.body.classList.contains('dark-mode');
    const difficultyColors = {
        beginner: getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim(),
        intermediate: getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim(),
        advanced: getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim(),
        all: isDarkMode ? '#ffffff' : getComputedStyle(document.documentElement).getPropertyValue('--all-levels-color').trim()
    };

    const validResults = results.filter(result => 
        result.wpm !== undefined && !isNaN(result.wpm) && result.date
    );

    // Check if there's any data
    if (validResults.length === 0) {
        // Create a dummy chart with no visible elements
        window.progressChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    data: []
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                aspectRatio: 2,
                scales: {
                    x: { display: false },
                    y: { display: false }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false },
                    // Custom plugin to draw the "No data" message
                    noData: {
                        color: isDarkMode ? '#f0f0f0' : '#333',
                        text: 'No data available for the selected time range',
                        fontSize: 20
                    }
                }
            },
            plugins: [{
                id: 'noData',
                afterDraw: (chart) => {
                    const { ctx, width, height } = chart;
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = `${chart.options.plugins.noData.fontSize}px Arial`;
                    ctx.fillStyle = chart.options.plugins.noData.color;
                    ctx.fillText(chart.options.plugins.noData.text, width / 2, height / 2);
                    ctx.restore();
                }
            }]
        });
        return; // Exit the function early
    }

    let chartData;
    if (timeRange === 'today') {
        chartData = validResults.filter(result => {
            const resultDate = new Date(result.date);
            return resultDate.toDateString() === new Date().toDateString();
        }).map(r => ({
            x: new Date(r.date),
            y: r.wpm,
            accuracy: r.accuracy,
            difficulty: r.difficulty,
            correctWords: r.correctWords,
            totalWords: r.totalWords,
            keystrokeAccuracy: r.keystrokeAccuracy,
            duration: r.duration
        }));
    } else if (timeRange === '6 months' || timeRange === '12 months') {
        const monthsToShow = timeRange === '6 months' ? 6 : 12;
        const now = new Date();
        const monthAgo = new Date(now.getFullYear(), now.getMonth() - monthsToShow + 1, 1);
        
        const aggregated = {};
        validResults.forEach(entry => {
            const date = new Date(entry.date);
            if (date >= monthAgo) {
                const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-01`;
                if (!aggregated[monthYear]) {
                    aggregated[monthYear] = { sum: 0, count: 0, highestWpm: 0, sessions: 0, totalAccuracy: 0, highestDifficulty: '' };
                }
                aggregated[monthYear].sum += entry.wpm;
                aggregated[monthYear].count++;
                aggregated[monthYear].totalAccuracy += entry.accuracy;
                aggregated[monthYear].sessions++;
                if (entry.wpm > aggregated[monthYear].highestWpm) {
                    aggregated[monthYear].highestWpm = entry.wpm;
                    aggregated[monthYear].highestDifficulty = entry.difficulty;
                }
            }
        });

        chartData = Object.entries(aggregated)
            .map(([monthYear, values]) => ({
                x: new Date(monthYear),
                y: Math.round(values.sum / values.count),
                accuracy: Math.round((values.totalAccuracy / values.count) * 100) / 100,
                highestWpm: values.highestWpm,
                highestDifficulty: values.highestDifficulty,
                sessions: values.sessions,
                label: new Date(monthYear).toLocaleString('default', { month: 'long', year: 'numeric' })
            }))
            .sort((a, b) => a.x - b.x);
    } else {
        const aggregated = {};
        validResults.forEach(result => {
            const date = new Date(result.date).toLocaleDateString();
            if (!aggregated[date]) {
                aggregated[date] = { totalWpm: 0, sessions: 0, totalAccuracy: 0, highestWpm: 0, highestDifficulty: '' };
            }
            aggregated[date].totalWpm += result.wpm;
            aggregated[date].totalAccuracy += result.accuracy;
            aggregated[date].sessions += 1;
            if (result.wpm > aggregated[date].highestWpm) {
                aggregated[date].highestWpm = result.wpm;
                aggregated[date].highestDifficulty = result.difficulty;
            }
        });

        chartData = Object.entries(aggregated).map(([date, data]) => ({
            x: new Date(date),
            y: Math.round(data.totalWpm / data.sessions),
            accuracy: Math.round((data.totalAccuracy / data.sessions) * 100) / 100,
            sessions: data.sessions,
            highestWpm: data.highestWpm,
            highestDifficulty: data.highestDifficulty
        }));
    }

    const datasets = [
        {
            label: 'Your WPM',
            data: chartData,
            borderColor: difficultyColors[difficulty] || difficultyColors['all'],
            backgroundColor: (difficulty === 'all' && !isDarkMode) ? 'rgba(75, 192, 192, 0.1)' : (isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(75, 192, 192, 0.1)'),
            tension: 0.1,
            borderWidth: 3,
            pointRadius: 2.5,
            pointBackgroundColor: function(context) {
                const index = context.dataIndex;
                return index === chartData.findIndex(d => d.y === Math.max(...chartData.map(d => d.y))) ? 'red' : (difficultyColors[difficulty] || difficultyColors['all']);
            },
        },
        {
            label: 'Average Typing Speed',
            data: chartData.map(d => ({ x: d.x, y: AVERAGE_TYPING_SPEED })),
            borderColor: isDarkMode ? 'rgba(255, 165, 0, 0.8)' : 'rgba(255, 99, 132, 0.8)',
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false,
            borderWidth: 2,
        },
        {
            label: 'Professional Typing Speed',
            data: chartData.map(d => ({ x: d.x, y: PROFESSIONAL_TYPING_SPEED })),
            borderColor: isDarkMode ? 'rgba(50, 205, 50, 0.8)' : 'rgba(54, 162, 235, 0.8)',
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false,
            borderWidth: 2,
        }
    ];

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        aspectRatio: 2,
        scales: {
            x: {
                type: 'time',
                time: {
                    unit: timeRange === 'today' ? 'hour' : 'day',
                    parser: 'yyyy-MM-dd HH:mm:ss',
                    tooltipFormat: 'PP'
                },
                title: {
                    display: true,
                    text: 'Date',
                    color: isDarkMode ? '#f0f0f0' : '#333'
                },
                ticks: {
                    color: isDarkMode ? '#f0f0f0' : '#333'
                },
                grid: {
                    color: isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)',
                    drawBorder: false
                }
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Words Per Minute',
                    color: isDarkMode ? '#f0f0f0' : '#333'
                },
                ticks: {
                    color: isDarkMode ? '#f0f0f0' : '#333',
                    callback: function(value) {
                        return Math.round(value);
                    }
                },
                grid: {
                    color: isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)',
                    drawBorder: false
                }
            }
        },
        plugins: {
            legend: {
                labels: {
                    usePointStyle: true,
                    pointStyle: 'line',
                    color: isDarkMode ? '#f0f0f0' : '#333'
                }
            },
            tooltip: {
                mode: 'nearest',
                intersect: true,
                callbacks: {
                    title: function(tooltipItems) {
                        const item = tooltipItems[0];
                        if (timeRange === 'today') {
                            const date = new Date(item.raw.x);
                            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        } else if (timeRange === '6 months' || timeRange === '12 months') {
                            return item.raw.label;
                        } else {
                            return new Date(item.raw.x).toLocaleDateString();
                        }
                    },
                    label: function(context) {
                        const dataPoint = context.raw;
                        if (!dataPoint || typeof dataPoint.y === 'undefined') return null;

                        let labels = [];
                        
                        if (timeRange === 'today') {
                            labels.push(`WPM: ${Math.round(dataPoint.y)}`);
                            if (dataPoint.accuracy) labels.push(`Accuracy: ${Math.round(dataPoint.accuracy)}%`);
                            if (difficulty === 'all' && dataPoint.difficulty) {
                                labels.push(`Difficulty: ${capitalizeFirstLetter(dataPoint.difficulty)}`);
                            }
                            if (dataPoint.duration) labels.push(`Test Duration: ${Math.round(dataPoint.duration / 60)} min`);
                            labels.push('Click to view more details');
                        } else {
                            labels.push(`Avg. WPM: ${Math.round(dataPoint.y)}`);
                            labels.push(`Avg Accuracy: ${Math.round(dataPoint.accuracy || 0)}%`);
                            if (dataPoint.highestWpm) {
                                if (difficulty === 'all' && dataPoint.highestDifficulty) {
                                    labels.push(`Highest WPM: ${Math.round(dataPoint.highestWpm)} (${capitalizeFirstLetter(dataPoint.highestDifficulty)})`);
                                } else {
                                    labels.push(`Highest WPM: ${Math.round(dataPoint.highestWpm)}`);
                                }
                            }
                            labels.push(`Sessions: ${dataPoint.sessions || 1}`);
                        }

                        return labels;
                    }
                }
            },
            annotation: {
                annotations: chartData.length > 0 ? {
                    bestLine: {
                        type: 'line',
                        xMin: chartData[chartData.findIndex(d => d.y === Math.max(...chartData.map(d => d.y)))].x,
                        xMax: chartData[chartData.findIndex(d => d.y === Math.max(...chartData.map(d => d.y)))].x,
                        borderColor: difficultyColors[difficulty] || difficultyColors['all'],
                        borderWidth: 2,
                        label: {
                            content: `Best: ${Math.ceil(Math.max(...chartData.map(d => d.y)))} WPM`,
                            enabled: true,
                            position: 'start',
                            yAdjust: -10,
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            color: '#ffffff',
                            padding: {
                                top: 4,
                                bottom: 4,
                                left: 6,
                                right: 6
                            },
                            borderRadius: 4,
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        }
                    }
                } : {}
            }
        },
        onClick: function(event, elements) {
            if (elements.length > 0 && timeRange === 'today') {
                const dataPoint = chartData[elements[0].index];
                showChartPointModal(dataPoint);
            }
        }
    };

    window.progressChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: datasets
        },
        options: chartOptions
    });
}

function aggregateDataByDay(results) {
    const aggregated = {};
    results.forEach(result => {
        const date = new Date(result.date).toLocaleDateString();
        if (!aggregated[date]) {
            aggregated[date] = { totalWpm: 0, sessions: 0, totalAccuracy: 0, highestWpm: 0, highestDifficulty: '' };
        }
        aggregated[date].totalWpm += result.wpm;
        aggregated[date].totalAccuracy += result.accuracy;
        aggregated[date].sessions += 1;
        if (result.wpm > aggregated[date].highestWpm) {
            aggregated[date].highestWpm = result.wpm;
            aggregated[date].highestDifficulty = result.difficulty;
        }
    });

    Object.keys(aggregated).forEach(date => {
        aggregated[date].avgWpm = aggregated[date].totalWpm / aggregated[date].sessions;
        aggregated[date].accuracy = aggregated[date].totalAccuracy / aggregated[date].sessions;
    });

    return aggregated;
}

function aggregateDataByMonth(data, timeRange) {
    const monthsToShow = timeRange === '6 months' ? 6 : 12;
    const now = new Date();
    const monthAgo = new Date(now.getFullYear(), now.getMonth() - monthsToShow + 1, 1);
    
    const aggregated = {};
    data.forEach(entry => {
        const date = new Date(entry.date);
        if (date >= monthAgo) {
            const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-01`;
            if (!aggregated[monthYear]) {
                aggregated[monthYear] = { sum: 0, count: 0, highestWpm: 0, sessions: 0, durations: [] };
            }
            aggregated[monthYear].sum += entry.wpm;
            aggregated[monthYear].count++;
            aggregated[monthYear].highestWpm = Math.max(aggregated[monthYear].highestWpm, entry.wpm);
            aggregated[monthYear].sessions++;
            aggregated[monthYear].durations.push(entry.duration || 60);
        }
    });

    return Object.entries(aggregated)
        .map(([monthYear, values]) => ({
            date: new Date(monthYear),
            y: Math.round(values.sum / values.count), // This is avgWpm
            accuracy: Math.round((values.totalAccuracy / values.count) * 100) / 100,
            highestWpm: values.highestWpm,
            highestDifficulty: values.highestDifficulty,
            sessions: values.sessions,
            label: new Date(monthYear).toLocaleString('default', { month: 'long', year: 'numeric' })
        }))
        .sort((a, b) => a.date - b.date);
}

function updateWordErrorTracker(word, isError) {
    if (!wordErrorTracker[word]) {
        wordErrorTracker[word] = { errors: 0, consecutiveErrors: 0 };
    }

    if (isError) {
        wordErrorTracker[word].errors++;
        wordErrorTracker[word].consecutiveErrors++;
    } else {
        wordErrorTracker[word].consecutiveErrors = 0;
    }

    // Consider a word problematic if it has more than 2 consecutive errors
    if (wordErrorTracker[word].consecutiveErrors > 2) {
        wordErrorTracker[word].isProblematic = true;
    }

    // Store the tracker in localStorage
    localStorage.setItem('wordErrorTracker', JSON.stringify(wordErrorTracker));
}

// Load word error tracker from localStorage on page load
function loadWordErrorTracker() {
    const savedTracker = localStorage.getItem('wordErrorTracker');
    if (savedTracker) {
        wordErrorTracker = JSON.parse(savedTracker);
    }
}

function updateWordErrorTracker(results) {
    let wordErrorTracker = {};

    results.forEach(result => {
        if (result.sessionProblematicWords) {
            for (const [word, data] of Object.entries(result.sessionProblematicWords)) {
                if (!wordErrorTracker[word]) {
                    wordErrorTracker[word] = { errors: 0, total: 0, totalTime: 0, totalKeystrokes: 0 };
                }
                wordErrorTracker[word].errors += data.errors;
                wordErrorTracker[word].total += data.total;
                wordErrorTracker[word].totalTime += data.totalTime;
                wordErrorTracker[word].totalKeystrokes += data.totalKeystrokes;
            }
        }
    });

    localStorage.setItem('wordErrorTracker', JSON.stringify(wordErrorTracker));
}

function updatePairErrorTracker(prevWord, currentWord, isError, time, userId = 'default') {
    let pairTracker = JSON.parse(localStorage.getItem(`pairErrorTracker_${userId}`)) || {};
    const pair = `${prevWord} ${currentWord}`;
    
    if (!pairTracker[pair]) {
        pairTracker[pair] = { errors: 0, total: 0, avgTime: 0 };
    }
    
    const data = pairTracker[pair];
    data.total++;
    
    if (isError) {
        data.errors++;
    }

    // Weighted moving average for time
    data.avgTime = ALPHA * time + (1 - ALPHA) * (data.avgTime || time);
    
    data.lastUpdated = Date.now();

    localStorage.setItem(`pairErrorTracker_${userId}`, JSON.stringify(pairTracker));
}

// Helper function to calculate average
function average(arr, prop) {
    return arr.reduce((sum, item) => sum + (prop === 'isError' ? (item[prop] ? 1 : 0) : item[prop]), 0) / arr.length;
}

function getSessionProblematicWords(count = 10) {
    return Object.entries(sessionProblematicWords)
        .map(([word, data]) => ({
            word,
            score: (data.totalTime / data.total) * (1 + data.errors / data.total) / (data.total / data.totalKeystrokes)
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, count)
        .map(item => item.word);
}

function updateProblematicWordsDisplay() {
    const problematicWords = getTopProblematicWords(10, true); // Add true to get only word strings
    const problematicWordsList = document.getElementById('problematic-words-list');
    if (problematicWordsList) {
        problematicWordsList.textContent = problematicWords.length > 0 
            ? problematicWords.join(', ') 
            : 'No problematic words found yet.';
    }
}

function updateProblematicWordsInModal() {
    const problematicWords = getTopProblematicWords(10, true); // Add true to get only word strings
    const problematicWordsList = document.getElementById('problematic-words-list');
    if (problematicWordsList) {
        if (problematicWords.length > 0) {
            const wordList = problematicWords.map((word, index) => 
                `<span class="problematic-word">${index + 1}. ${word}</span>`
            ).join(' ');
            problematicWordsList.innerHTML = wordList;
        } else {
            problematicWordsList.textContent = 'No challenging words found yet.';
        }
    }
}

function updateWordErrorTracker(word, isError) {
    if (!wordErrorTracker[word]) {
        wordErrorTracker[word] = { errors: 0, consecutiveErrors: 0 };
    }

    if (isError) {
        wordErrorTracker[word].errors++;
        wordErrorTracker[word].consecutiveErrors++;
    } else {
        wordErrorTracker[word].consecutiveErrors = 0;
    }

    // Consider a word problematic if it has more than 2 consecutive errors
    if (wordErrorTracker[word].consecutiveErrors > 2) {
        wordErrorTracker[word].isProblematic = true;
    }

    // Store the tracker in localStorage
    localStorage.setItem('wordErrorTracker', JSON.stringify(wordErrorTracker));
}

        

        function showCustomTestResult() {
            console.log('Entering showCustomTestResult');
            if (!resultContent) {
                console.error('resultContent is not defined');
                return;
            }
            const wpm = parseInt(wpmDisplay.textContent);
            const accuracy = calculateAccuracy();
            const wordAccuracy = Math.round((correctWords / totalWords) * 100);
            const keystrokeAccuracy = Math.round((correctKeystrokes / totalKeystrokes) * 100);
            const avgWordTime = totalWordTime > 0 ? (totalWordTime / wordCount).toFixed(2) : '0.00';
            const customColor = '#34495e';  // Specified color for custom tests

            const encouragementMsg = getEncouragementMessage(wpm, accuracy);
            const isDarkMode = document.body.classList.contains('dark-mode');

            resultContent.innerHTML = `
            <div style="text-align: center; margin-bottom: 30px;">
                <h2 style="font-size: 32px; margin-bottom: 15px;">Your Custom Test Results</h2>
                <p style="font-size: 20px;">${encouragementMsg}</p>
            </div>
            <div style="display: flex; justify-content: center; gap: 200px; margin-bottom: 30px;">
                <div style="text-align: center;">
                    <h3 style="font-size: 50px; margin: 0; color: ${customColor};">${wpm}</h3>
                    <p style="font-size: 18px; opacity: 0.8;">Words Per Minute</p>
                </div>
                <div style="text-align: center;">
                    <h3 style="font-size: 50px; margin: 0; color: ${customColor};">${accuracy}%</h3>
                    <p style="font-size: 18px; opacity: 0.8;">Overall Accuracy</p>
                </div>
            </div>
            <div style="background-color: rgba(200, 200, 200, 0.5); border-radius: 8px; padding: 20px; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
                <h4 style="text-align: center; margin-top: 0; margin-bottom: 15px; font-size: 22px;">
                    Test Duration: <span style="color: ${customColor};">${selectedTime} seconds</span>
                </h4>
                <div style="display: flex; justify-content: space-between;">
                    <div style="flex: 1; padding-right: 20px; border-right: 1px solid #999;">
                        <p><strong>Correct Words:</strong> ${correctWords} / ${totalWords}</p>
                        <p><strong>Word Accuracy:</strong> ${wordAccuracy}%</p>
                        <p><strong>Avg. Word Time:</strong> ${avgWordTime}s</p>
                    </div>
                    <div style="flex: 1; padding-left: 20px;">
                        <p><strong>Keystrokes:</strong> ${totalKeystrokes} (<span style="color: #4CAF50;">${correctKeystrokes}</span> | <span style="color: #f44336;">${incorrectKeystrokes}</span>)</p>
                        <p><strong>Keystroke Accuracy:</strong> ${keystrokeAccuracy}%</p>
                    </div>
                </div>
            </div>
            <div style="width: 100%; max-width: 900px; height: 350px; margin-bottom: 30px; margin-left: auto; margin-right: auto;">
                <canvas id="performance-chart"></canvas>
            </div>
            <div style="text-align: center; margin-top: 20px;">
            <p style="font-style: italic; color: #666;">Note: Custom test results are not saved and do not affect your overall statistics or problematic words tracking.</p>
            </div>
        `;

        createPerformanceChart(customColor, isDarkMode);
        console.log('Custom test result content set');
    }

    function updateModalTheme() {
        const isDarkMode = document.body.classList.contains('dark-mode');
        const modal = document.getElementById('progressModal');
        if (modal) {
            if (isDarkMode) {
                modal.classList.add('dark-mode');
            } else {
                modal.classList.remove('dark-mode');
            }
        }
    }

    function getCurrentDifficulty() {
        const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
        const position = parseFloat(sliderHandle.style.left) || 0;
        
        if (position === 0) return 'beginner';
        if (position === 33.33) return 'intermediate';
        if (position === 66.66) return 'advanced';
        
        // If no valid position is found, return null or a default value
        return null;
    }

   

    

function openProgressModal() {
    isProgressModalOpen = true;
    if (difficultySelected) {
        lastUsedDifficulty = currentDifficulty;
    }
    loadData().then(data => {
        if (data.length === 0) {
            alert("No progress data available. Complete a test first!");
            return;
        }

        currentPageIndex = 0;
        showPage(0);

        originalData = data;
        currentFilteredData = [...data];

        const stats = calculateStats(currentFilteredData);
        updateProgressStats(stats, currentFilteredData);
        drawProgressChart(currentFilteredData, 'all', 'all'); // Initial chart draw

        // Reset progress modal difficulty to 'all'
        const progressSliderHandle = document.querySelector('#difficulty-filter .slider-handle');
        if (progressSliderHandle) {
            progressSliderHandle.style.left = '0%';
        }
        const progressSliderOptions = document.querySelectorAll('#difficulty-filter .slider-option');
        progressSliderOptions.forEach((option, index) => {
            option.classList.toggle('selected', index === 0);
        });
        filterByDifficulty('all');

        // Reset to the first page
        currentPage = 0;
        const pages = document.querySelectorAll('.carousel-page');
        pages.forEach(page => {
            page.style.transform = `translateX(0%)`;
        });

        // Show the modal
        const modal = document.getElementById('progressModal');
        if (modal) {
            modal.style.display = 'flex';
        } else {
            console.error('Progress modal not found');
        }

        // Update achievements display
        if (achievementSystem) {
            achievementSystem.updateProgressModal();
        } else {
            console.error('Achievement system not initialized');
        }

        // Apply current theme
        updateModalTheme();

        initializeDifficultyFilter();

        console.log('Progress modal opened');
    });
    initializeProgressDifficultySlider();

    updateProblematicWordsInModal();
    updateProgressModalProblematicWords();
}

function filterByDifficulty(difficulty) {
    console.log('Filtering by difficulty:', difficulty);
    currentDifficulty = difficulty; // Update the current difficulty
    const timeRange = document.getElementById('time-range-selector').value;
    
    let allResults = JSON.parse(localStorage.getItem('typingResults')) || [];
    
    const now = new Date();
    currentFilteredData = allResults.filter(result => {
        const resultDate = new Date(result.date);
        if (timeRange !== 'all') {
            if (timeRange === 'today') {
                if (resultDate.toDateString() !== now.toDateString()) return false;
            } else {
                const days = parseInt(timeRange);
                if ((now - resultDate) > days * 24 * 60 * 60 * 1000) return false;
            }
        }
        
        return difficulty === 'all' || result.difficulty === difficulty;
    });

    console.log('Filtered data:', currentFilteredData);

    const stats = calculateStats(currentFilteredData);
    console.log('Calculated stats:', stats);

    updateProgressStats(stats, currentFilteredData);
    drawProgressChart(currentFilteredData, timeRange, difficulty);

    // Update slider position and colors
    const progressSliderHandle = document.querySelector('#difficulty-filter .slider-handle');
    const progressSliderOptions = document.querySelectorAll('#difficulty-filter .slider-option');
    let position, color;

    switch (difficulty) {
        case 'all':
            position = 0;
            color = getComputedStyle(document.documentElement).getPropertyValue('--all-levels-color').trim();
            break;
        case 'beginner':
            position = 25;
            color = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
            break;
        case 'intermediate':
            position = 50;
            color = getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim();
            break;
        case 'advanced':
            position = 75;
            color = getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim();
            break;
        default:
            position = 0;
            color = getComputedStyle(document.documentElement).getPropertyValue('--all-levels-color').trim();
    }

    progressSliderHandle.style.left = `${position}%`;
    progressSliderHandle.style.backgroundColor = color;

    progressSliderOptions.forEach((option, index) => {
        option.classList.toggle('selected', index === position / 25);
        option.style.color = index === position / 25 ? '#ffffff' : ''; // White text for selected option
    });

    console.log('Filter applied. Current difficulty:', currentDifficulty);
}

function initializeDifficultyFilter() {
    const initialDifficulty = 'all';
    const initialPosition = 0;
    const progressSliderHandle = document.querySelector('#difficulty-filter .slider-handle');
    const sliderOptions = document.querySelectorAll('#difficulty-filter .slider-option');
    
    progressSliderHandle.style.left = `${initialPosition}%`;
    sliderOptions[0].classList.add('selected');
    
    filterByDifficulty(initialDifficulty);
}



function filterByTimeRange() {
    const timeRange = document.getElementById('time-range-selector').value;
    console.log('Filtering by time range:', timeRange);

    let allResults = JSON.parse(localStorage.getItem('typingResults')) || [];
    
    const now = new Date();
    currentFilteredData = allResults.filter(result => {
        const resultDate = new Date(result.date);
        if (timeRange !== 'all') {
            if (timeRange === 'today') {
                return resultDate.toDateString() === now.toDateString();
            } else {
                const days = parseInt(timeRange);
                return (now - resultDate) <= days * 24 * 60 * 60 * 1000;
            }
        }
        return true;
    }).filter(result => currentDifficulty === 'all' || result.difficulty === currentDifficulty);

    console.log('Filtered data:', currentFilteredData);

    const stats = calculateStats(currentFilteredData);
    updateProgressStats(stats, currentFilteredData);

    // Always call drawProgressChart, even if there's no data
    drawProgressChart(currentFilteredData, timeRange, currentDifficulty);

    // Update other UI elements if necessary
    updateProblematicWordsDisplay();
    updateProgressModalProblematicWords();
}

    function getResults() {
        return JSON.parse(localStorage.getItem('typingResults')) || [];
    }

    function calculateStats(results) {
        if (results.length === 0) {
            return {
                avgWpm: 0,
                avgAccuracy: 0,
                highestWpm: 0,
                comparedToAverage: 0,
                comparedToProfessional: 0
            };
        }

        const totalWpm = results.reduce((sum, r) => sum + r.wpm, 0);
        const totalAccuracy = results.reduce((sum, r) => sum + r.accuracy, 0);
        const highestWpm = Math.max(...results.map(r => r.wpm));
        const avgWpm = Math.round(totalWpm / results.length);

        return {
            avgWpm: avgWpm,
            avgAccuracy: Math.round(totalAccuracy / results.length),
            highestWpm: highestWpm,
            comparedToAverage: avgWpm - AVERAGE_TYPING_SPEED,
            comparedToProfessional: avgWpm - PROFESSIONAL_TYPING_SPEED          
        };
    }

    function calculateWPM() {
        const elapsedTime = (new Date() - startTime) / 1000 / 60; // in minutes
        const wpm = Math.round(correctWords / elapsedTime);
        return wpm;
    }


    function getEncouragementMessage(wpm, accuracy) {
        if (wpm === 69 || accuracy === 69) return "NOOOICE!!! üòú";
        if (wpm < 30) return "Keep practicing! You're on your way to becoming a typing pro! üëç";
        if (wpm < 50) return "Good job! You're making progress. Keep it up! üöÄ";
        if (wpm < 70) return "Great work! You're typing faster than the average person! ü§©";
        return "Wow! üåü You're a typing master! Incredible speed! üåü";
    }

    function findMostChallengingWord(results) {
        const wordErrorCounts = {};
        results.forEach(result => {
            Object.entries(result.wordErrors || {}).forEach(([word, count]) => {
                wordErrorCounts[word] = (wordErrorCounts[word] || 0) + count;
            });
        });

        let mostChallengingWord = '';
        let maxErrors = 0;

        Object.entries(wordErrorCounts).forEach(([word, count]) => {
            if (count > maxErrors) {
                mostChallengingWord = word;
                maxErrors = count;
            }
        });

        return mostChallengingWord || 'N/A';
    }

    function updateTestInstructionsPosition() {
        const testInstructions = document.getElementById('test-instructions');
        const keyboardContainer = document.getElementById('keyboard-container');
        const isUIHidden = document.body.classList.contains('hide-ui');
        const isKeyboardVisible = keyboardContainer && keyboardContainer.style.display !== 'none';

        if (isUIHidden && isKeyboardVisible) {
            testInstructions.style.bottom = '240px';
        } else if (isUIHidden) {
            testInstructions.style.bottom = '100px';
        } else if (isKeyboardVisible) {
            testInstructions.style.bottom = '220px';
        } else {
            testInstructions.style.bottom = '20px';
        }
    }

    


    function updateStatsDisplay(stats) {
        // Update your stats display elements with the calculated stats
        document.getElementById('average-wpm').textContent = stats.averageWPM.toFixed(2);
        document.getElementById('average-accuracy').textContent = (stats.averageAccuracy * 100).toFixed(2) + '%';
        document.getElementById('highest-wpm').textContent = stats.highestWPM.toFixed(2);
        // Update other stats as needed
    }

    function loadData() {
        return new Promise((resolve) => {
            // Here, we're using the existing data from localStorage
            const results = JSON.parse(localStorage.getItem('typingResults')) || [];
            resolve(results);
        });
    }

    function getScreenScale() {
    return window.devicePixelRatio || 1;
    }

    function adjustModalSize() {
        const scale = getScreenScale();
        const modals = document.querySelectorAll('.modal');
        
        modals.forEach(modal => {
            const content = modal.querySelector('.modal-content');
            content.style.transform = `scale(${1 / scale})`;
            content.style.transformOrigin = 'center center';
            modal.style.fontSize = `${16 * scale}px`;
        });
        }

        function updateProgressStats(stats, results) {
            console.log('Updating progress stats. Current difficulty:', currentDifficulty);

            function updateElementWithTrend(id, value, previousValue, isPercentage = false) {
                const element = document.getElementById(id);
                if (element) {
                    let trendIcon = '';
                    if (value > previousValue) {
                        trendIcon = '<span class="trend-arrow" style="color: green;">‚ñ≤</span>';
                    } else if (value < previousValue) {
                        trendIcon = '<span class="trend-arrow" style="color: red;">‚ñº</span>';
                    }
                    element.innerHTML = `${trendIcon} ${value}${isPercentage ? '%' : ''}`;
                }
            }

            function formatComparisonText(value) {
                if (value === 0) return '0 WPM';
                const sign = value > 0 ? '+' : '-';
                const color = value > 0 ? 'green' : 'red';
                return `<span style="color: ${color};">${sign}${Math.abs(value)}</span> WPM`;
            }

            const timeRange = document.getElementById('time-range-selector').value;
            const previousPeriodStats = calculatePreviousPeriodStats(results, timeRange, currentDifficulty);

            updateElementWithTrend('avg-wpm', stats.avgWpm, previousPeriodStats.avgWpm);
            updateElementWithTrend('avg-accuracy', stats.avgAccuracy, previousPeriodStats.avgAccuracy, true);

            document.getElementById('compared-to-average').innerHTML = formatComparisonText(stats.comparedToAverage);
            document.getElementById('compared-to-professional').innerHTML = formatComparisonText(stats.comparedToProfessional);

            const highestWPM = Math.max(0, ...results.map(entry => entry.wpm || 0));
            document.getElementById('highest-wpm').textContent = highestWPM;

            const difficultyIndicator = document.getElementById('highest-wpm-difficulty');
            if (currentDifficulty === 'all' && results.length > 0) {
                const highestWPMEntry = results.find(entry => entry.wpm === highestWPM);
                console.log('Highest WPM Entry:', highestWPMEntry);
                if (highestWPMEntry && highestWPMEntry.difficulty) {
                    // Capitalize the first letter of the difficulty
                    const capitalizedDifficulty = highestWPMEntry.difficulty.charAt(0).toUpperCase() + highestWPMEntry.difficulty.slice(1);
                    difficultyIndicator.textContent = capitalizedDifficulty;
                    difficultyIndicator.style.color = getDifficultyColor(highestWPMEntry.difficulty);
                    console.log('Setting difficulty indicator:', difficultyIndicator.textContent);
                } else {
                    difficultyIndicator.textContent = '';
                    console.log('Clearing difficulty indicator (no valid entry)');
                }
            } else {
                difficultyIndicator.textContent = '';
                console.log('Clearing difficulty indicator (not "all" difficulty)');
            }
        }


        function calculatePreviousPeriodStats(results, timeRange, difficulty) {
            const now = new Date();
            let previousPeriodStart, previousPeriodEnd;

            switch(timeRange) {
                case 'today':
                    previousPeriodStart = new Date(now.setDate(now.getDate() - 1));
                    previousPeriodEnd = new Date();
                    break;
                case '7':
                    previousPeriodStart = new Date(now.setDate(now.getDate() - 14));
                    previousPeriodEnd = new Date(now.setDate(now.getDate() + 7));
                    break;
                case '30':
                    previousPeriodStart = new Date(now.setDate(now.getDate() - 60));
                    previousPeriodEnd = new Date(now.setDate(now.getDate() + 30));
                    break;
                case '90':
                    previousPeriodStart = new Date(now.setDate(now.getDate() - 180));
                    previousPeriodEnd = new Date(now.setDate(now.getDate() + 90));
                    break;
                default:
                    // For 'all' or any other case, use all previous data
                    previousPeriodStart = new Date(0);
                    previousPeriodEnd = new Date();
            }

            const previousPeriodResults = results.filter(result => {
                const resultDate = new Date(result.date);
                return resultDate >= previousPeriodStart && resultDate < previousPeriodEnd &&
                    (difficulty === 'all' || result.difficulty === difficulty);
            });

            if (previousPeriodResults.length === 0) {
                return { avgWpm: 0, avgAccuracy: 0 };
            }

            const totalWpm = previousPeriodResults.reduce((sum, result) => sum + result.wpm, 0);
            const totalAccuracy = previousPeriodResults.reduce((sum, result) => sum + result.accuracy, 0);

            return {
                avgWpm: Math.round(totalWpm / previousPeriodResults.length),
                avgAccuracy: Math.round(totalAccuracy / previousPeriodResults.length)
            };
        }

function savePreviousStats(timeRange, difficulty, stats) {
    const key = `previousStats_${timeRange}_${difficulty}`;
    localStorage.setItem(key, JSON.stringify({
        avgWpm: stats.avgWpm,
        avgAccuracy: stats.avgAccuracy
    }));
}

    function initializeLastKnownValues() {
        const savedValues = getLocalStorage('lastKnownValues');
        if (savedValues) {
            lastKnownValues['avg-wpm'] = savedValues['avg-wpm'];
            lastKnownValues['avg-accuracy'] = savedValues['avg-accuracy'];
        }
    }

    function saveLastKnownValues() {
        setLocalStorage('lastKnownValues', lastKnownValues);
    }



    function resetLastKnownValues() {
        lastKnownValues['avg-wpm'] = {};
        lastKnownValues['avg-accuracy'] = {};
    }



    function formatComparisonText(value) {
        if (value === 0) return '0 WPM';
        const sign = value > 0 ? '+' : '-';
        const color = value > 0 ? 'green' : 'red';
        return `<span style="color: ${color};">${sign}</span>${Math.abs(value)} WPM`;
    }

    // Default values if there are no results
    const avgWpm = results.length > 0 ? stats.avgWpm + ' WPM' : '0 WPM';
    const avgAccuracy = results.length > 0 ? stats.avgAccuracy + '%' : '0%';
    const highestWpm = results.length > 0 ? stats.highestWpm + ' WPM' : '0 WPM';
    const comparedToAverage = results.length > 0 ? stats.avgWpm - AVERAGE_TYPING_SPEED : 0;
    const comparedToProfessional = results.length > 0 ? stats.avgWpm - PROFESSIONAL_TYPING_SPEED : 0;

    updateElement('avg-wpm', avgWpm);
    updateElement('avg-accuracy', avgAccuracy);
    updateElement('highest-wpm', highestWpm);

    // Update comparisons
    updateElement('compared-to-average', comparedToAverage, true);
    updateElement('compared-to-professional', comparedToProfessional, true);

    function updateElement(id, value, isComparison = false) {
    const element = document.getElementById(id);
    if (element) {
        if (isComparison && results.length > 0) {
            element.innerHTML = formatComparisonText(value);
        } else {
            element.textContent = value;
        }
    } else {
        console.warn(`Element with id '${id}' not found`);
    }
}


    function setComparisonColor(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            const span = element.querySelector('span');
            if (span) {
                if (value > 0) {
                    span.style.color = 'green';
                } else {
                    span.style.color = 'red';
                }
            }
        }
    }

    function addButtonEventListeners() {
        document.getElementById('dark-mode-toggle').addEventListener('change', toggleDarkMode);
        document.getElementById('keyboard-heatmap-toggle').addEventListener('change', toggleHeatmap);

        
        

        // Modal buttons
        const closeButton = document.querySelector('.modal-buttons .close-button');
        if (closeButton) {
            closeButton.addEventListener('click', () => closeModal('progressModal'));
        }
        const resetProgressButton = document.querySelector('.modal-buttons #reset-progress');
        if (resetProgressButton) {
            resetProgressButton.addEventListener('click', openResetModal);
        }
    }

    

    function updateButtonColors() {
        const isDarkMode = document.body.classList.contains('dark-mode');
        const generalButtons = document.querySelectorAll('button:not(#beginner-btn):not(#intermediate-btn):not(#advanced-btn):not(#all-levels-btn):not(#beginner-filter-btn):not(#intermediate-filter-btn):not(#advanced-filter-btn):not(#all-levels-btn):not(#reset-progress)');

        generalButtons.forEach(button => {
            if (isDarkMode) {
                button.style.backgroundColor = '#444444';
                button.style.color = '#ffffff';
            } else {
                button.style.backgroundColor = '';
                button.style.color = '';
            }
        });

        // Ensure difficulty buttons maintain their specific colors and text colors
        const specialButtons = {
            'beginner': ['beginner-btn', 'beginner-filter-btn'],
            'intermediate': ['intermediate-btn', 'intermediate-filter-btn'],
            'advanced': ['advanced-btn', 'advanced-filter-btn'],
            'all-levels': ['all-levels-btn'],
            'reset': ['reset-progress']
        };

        Object.entries(specialButtons).forEach(([type, ids]) => {
            ids.forEach(id => {
                const button = document.getElementById(id);
                if (button) {
                    if (type === 'reset') {
                        button.style.backgroundColor = 'var(--reset-button-color)';
                        button.style.color = 'var(--reset-button-text-color)';
                    } else {
                        button.style.backgroundColor = `var(--${type}-color)`;
                        button.style.color = `var(--${type}-text-color)`;
                    }
                }
            });
        });
    }

    function toggleDarkMode() {
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const isDarkMode = !document.body.classList.contains('dark-mode');
        
        // Toggle the dark mode class on the body
        document.body.classList.toggle('dark-mode', isDarkMode);
        
        // Update the toggle switch state
        darkModeToggle.checked = isDarkMode;
        
        // Save the preference
        localStorage.setItem('darkMode', isDarkMode);
        
        // Update other UI elements as needed
        updateButtonColors();
        achievementSystem.updateProgressModal();
        updateKeyboardColors();
        
        // Reapply the current difficulty to update slider text color
        if (currentDifficulty) {
            setDifficulty(currentDifficulty);
        }
        
        // Redraw the chart if it exists
        if (window.progressChart) {
            const results = getResults();
            drawProgressChart(results);
        }
        
        // Ensure the start button retains the highlight color or default style
        updateStartButtonStyle();
    }

    function updateKeyboardColors() {
        const keys = document.querySelectorAll('.key');
        const isDarkMode = document.body.classList.contains('dark-mode');
        
        keys.forEach(key => {
            // Update key colors based on dark mode
            key.style.backgroundColor = isDarkMode ? '#444444' : '#ffffff';
            key.style.color = isDarkMode ? '#ffffff' : '#000000';
            
            // If heatmap is enabled, apply heat colors
            if (heatmapEnabled) {
                const keyChar = key.textContent.toLowerCase();
                const intensity = Math.min((keyPressCount[keyChar] || 0) / MAX_INTENSITY, 1);
                const heatColor = getHeatColor(intensity);
                key.style.backgroundColor = heatColor;
            }
            
            // Apply border color based on current difficulty
            if (currentHighlightColor) {
                key.style.borderColor = currentHighlightColor;
            }
        });
    }


    
    

    function shareResults() {
        const resultsElement = document.querySelector('#results .modal-content'); // Select only the modal content
        const now = new Date();
        const dateSuffix = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
        const filename = `typing_test_results_${dateSuffix}.png`;

        html2canvas(resultsElement).then(canvas => {
            // Convert the canvas to a data URL
            const dataUrl = canvas.toDataURL('image/png');
            
            // Create a link element
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = filename;
            
            // Trigger the download
            link.click();
        }).catch(error => {
            console.error('Error capturing screenshot:', error);
        });
    }

    function calculateAccuracy() {
        const wordAccuracy = totalWords > 0 ? (correctWords / totalWords) * 100 : 100;
        const keystrokeAccuracy = totalKeystrokes > 0 ? (correctKeystrokes / totalKeystrokes) * 100 : 100;
        
        // If no keystrokes have been made, return 100% accuracy
        if (totalKeystrokes === 0) {
            return 100;
        }
        
        const overallAccuracy = (wordAccuracy + keystrokeAccuracy) / 2;
        
        return Math.round(overallAccuracy);
    }

    function updateStats() {
        const elapsedTime = (new Date() - startTime) / 1000 / 60; // in minutes
        const wpm = elapsedTime > 0 ? Math.round(correctWords / elapsedTime) : 0;
        const accuracy = calculateAccuracy();
        const wordAccuracy = totalWords > 0 ? Math.round((correctWords / totalWords) * 100) : 100;
        const keystrokeAccuracy = totalKeystrokes > 0 ? Math.round((correctKeystrokes / totalKeystrokes) * 100) : 100;

        wpmDisplay.textContent = wpm;
        accuracyDisplay.textContent = `${accuracy}%`;
        document.getElementById('word-accuracy').innerText = `Word: ${wordAccuracy}%`;
        document.getElementById('key-accuracy').innerText = `Key: ${keystrokeAccuracy}%`;

    }

    function checkWord(typedWord, currentWord) {
        // Remove trailing punctuation for comparison
        const trimmedTypedWord = typedWord.replace(/[.,;:!?]$/, '');
        const trimmedCurrentWord = currentWord.replace(/[.,;:!?]$/, '');

        if (trimmedTypedWord === trimmedCurrentWord) {
            // If the words match without punctuation, check if punctuation was correct (if present)
            return typedWord === currentWord;
        }
        return false;
    }
    

    function showChartPointModal(dataPoint) {
    const chartPointContent = document.getElementById('chart-point-content');
    const chartPointModal = document.getElementById('chartPointModal');
    
    const wpm = Math.round(dataPoint.y);
    const accuracy = Math.round(dataPoint.accuracy);
    const correctWords = dataPoint.correctWords;
    const totalWords = dataPoint.totalWords;
    const keystrokeAccuracy = Math.round(dataPoint.keystrokeAccuracy);
    const duration = Math.round(dataPoint.duration / 60); // Convert to minutes and round

    const encouragementMsg = getEncouragementMessage(wpm, accuracy);
    const difficultyColor = getDifficultyColor(dataPoint.difficulty);
    const difficultyName = getDifficultyName(dataPoint.difficulty);
    const isDarkMode = document.body.classList.contains('dark-mode');

    chartPointContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="font-size: 32px; margin-bottom: 15px;">Your <span style="color: ${difficultyColor};">${difficultyName}</span> Results</h2>
            <p style="font-size: 20px;">${encouragementMsg}</p>
        </div>
        <div style="display: flex; justify-content: center; gap: 200px; margin-bottom: 30px;">
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${wpm}</h3>
                <p style="font-size: 18px; opacity: 0.8;">Words Per Minute</p>
            </div>
            <div style="text-align: center;">
                <h3 style="font-size: 50px; margin: 0; color: ${difficultyColor};">${accuracy}%</h3>
                <p style="font-size: 18px; opacity: 0.8;">Overall Accuracy</p>
            </div>
        </div>
        <div style="background-color: ${isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)'}; border-radius: 8px; padding: 20px; margin-bottom: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h4 style="text-align: center; margin-top: 0; margin-bottom: 15px; font-size: 22px;">
                Test Duration: <span style="color: ${difficultyColor};">${duration} minute${duration !== 1 ? 's' : ''}</span>
            </h4>
            <div style="display: flex; justify-content: space-between;">
                <div style="flex: 1; padding-right: 20px; border-right: 1px solid ${isDarkMode ? '#555' : '#ddd'};">
                    <p><strong>Correct Words:</strong> ${correctWords} / ${totalWords}</p>
                    <p><strong>Word Accuracy:</strong> ${Math.round((correctWords / totalWords) * 100)}%</p>
                </div>
                <div style="flex: 1; padding-left: 20px;">
                    <p><strong>Keystroke Accuracy:</strong> ${keystrokeAccuracy}%</p>
                </div>
            </div>
        </div>
    `;

    // Apply difficulty color to modal background
    chartPointModal.style.backgroundColor = `${isDarkMode ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)'}`;
    chartPointModal.style.border = `2px solid ${difficultyColor}`;
    chartPointModal.style.boxShadow = `0 0 10px ${difficultyColor}`;

    chartPointModal.style.display = 'flex';
    chartPointModal.style.visibility = 'visible';
    chartPointModal.style.opacity = '1';
    chartPointModal.style.zIndex = '1002';  // Ensure this is higher than other modals
}

function closeModal(modalId) {
    if (modalId === 'progressModal') {
        closeProgressModal();
    } else {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
            modal.classList.remove('modal-open');
            if (modalId === 'results') {
                isResultModalOpen = false;
            }
        } else {
            console.error(`Modal with id ${modalId} not found`);
        }
    }
}

function showModal(modalId) {
    if (modalId === 'results' && isResultModalOpen) {
        return; // Don't open the modal if it's already open
    }

    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
        console.log(`Showing modal: ${modalId}`);
        
        if (modalId === 'results') {
            isResultModalOpen = true;
        }
    } else {
        console.error(`Modal not found: ${modalId}`);
    }
}

function closeChartPointModal() {
    const chartPointModal = document.getElementById('chartPointModal');
    chartPointModal.style.display = 'none';
}

function getTopProblematicWords(count = 10, wordsOnly = false) {
    console.log('getTopProblematicWords called with:', { count, wordsOnly });
    const tracker = JSON.parse(localStorage.getItem('wordErrorTracker')) || {};
    console.log('Raw tracker data:', tracker);

    const sortedWords = Object.entries(tracker)
        .map(([word, data]) => {
            console.log('Processing word:', word, 'Data:', data);
            return { word, score: data.errors / data.total, difficulty: data.difficulty };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, count);

    console.log('Sorted words:', sortedWords);

    if (wordsOnly) {
        const wordList = sortedWords.map(item => item.word);
        console.log('Words only (about to return):', wordList);
        return wordList;
    }
    return sortedWords;
}


    function openResetModal() {
        closeModal('progressModal');
        showModal('resetModal');
    }

    function resetProgress() {
    // Clear all relevant items from localStorage
    localStorage.removeItem('typingResults');
    localStorage.removeItem('unlockedAchievements');
    localStorage.removeItem('totalWordsTyped');
    localStorage.removeItem('lastKnownValues');
    localStorage.removeItem('wordErrorTracker');
    localStorage.removeItem('visualizerOpacity');

    localStorage.removeItem('waveVisualizerUnlocked');
    waveVisualizerUnlocked = false;
    document.getElementById('waveVisualizer').style.display = 'none';
    document.querySelector('.visualizer-opacity-slider').style.display = 'none';
    
    // Reset the AchievementSystem
    if (achievementSystem) {
        achievementSystem.unlockedAchievements = [];
        achievementSystem.saveUnlockedAchievements();
    }
    
    // Reset global variables
    typingResults = [];
    wordErrorTracker = {};
    lastKnownValues = { 'avg-wpm': {}, 'avg-accuracy': {} };
    
    // Update UI elements
    updateProgressStats({
        avgWpm: 0,
        avgAccuracy: 0,
        highestWpm: 0,
        comparedToAverage: 0,
        comparedToProfessional: 0
    }, []);
    
    // Redraw the progress chart with empty data
    drawProgressChart([], 'all', 'all');
    
    // Update the achievements display
    if (achievementSystem) {
        achievementSystem.updateProgressModal();
    }
    
    // Reset the difficulty filter
    filterByDifficulty('all');
    
    // Close the reset modal
    closeModal('resetModal');

    // Alert the user and reload the page
    setTimeout(() => {
        alert('Your progress has been completely reset.');
        location.reload();
    }, 100);
}

    // Add this function to verify the reset
function verifyReset() {
    console.log('Typing Results:', JSON.parse(localStorage.getItem('typingResults')));
    console.log('Unlocked Achievements:', JSON.parse(localStorage.getItem('unlockedAchievements')));
    console.log('Total Words Typed:', localStorage.getItem('totalWordsTyped'));
    console.log('Last Known Values:', JSON.parse(localStorage.getItem('lastKnownValues')));
    console.log('Word Error Tracker:', JSON.parse(localStorage.getItem('wordErrorTracker')));
}




    function updateHighestWpmDifficulty(difficulty) {
        const highestWpmDifficultyElement = document.getElementById('highest-wpm-difficulty');
        let difficultyName = '';
        let difficultyColor = '';

        switch (difficulty) {
            case 'beginner':
                difficultyName = 'Beginner';
                difficultyColor = getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
                break;
            case 'intermediate':
                difficultyName = 'Intermediate';
                difficultyColor = getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim();
                break;
            case 'advanced':
                difficultyName = 'Advanced';
                difficultyColor = getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim();
                break;
            default:
                difficultyName = '';
                difficultyColor = '';
                break;
        }

        highestWpmDifficultyElement.textContent = difficultyName;
        highestWpmDifficultyElement.style.color = difficultyColor;
    }
    





    function initialLoad() {
        const results = JSON.parse(localStorage.getItem('typingResults')) || [];
        const stats = calculateStats(results);
        updateProgressStats(stats, results);
        drawProgressChart(results);
        document.getElementById('time-range-selector').value = 'today';
        filterByTimeRange();
    }

    window.onclick = function(event) {
            var modals = document.getElementsByClassName('modal');
            for (var i = 0; i < modals.length; i++) {
                if (event.target == modals[i]) {
                    modals[i].style.display = "none";
                }
            }
        }

    function changeFontSize() {
        const size = document.getElementById('font-size-selector').value;
        typingArea.style.fontSize = `${size}px`;
        localStorage.setItem('preferredFontSize', size);
    }

    function loadSavedFontSize() {
        const savedSize = localStorage.getItem('preferredFontSize');
        if (savedSize) {
            typingArea.style.fontSize = `${savedSize}px`;
        }
    }

    function addRandomPunctuation(words, probability = 0.3) {
    return words.map(word => {
        // Check if the word already ends with punctuation
        if (/[.,;:!?]$/.test(word)) {
            return word; // Return the word unchanged if it already has punctuation
        }
        
        // If no existing punctuation, proceed with the random addition
        if (Math.random() < probability && word.length > 3) {
            const punctuationChance = Math.random();
            if (punctuationChance < 0.30) {
                return word + ',';
            } else if (punctuationChance < 0.60) {
                return word + '.';
            } else if (punctuationChance < 0.70) {
                return word + ':';
            } else if (punctuationChance < 0.80) {
                return word + ';';
            } else if (punctuationChance < 0.90) {
                return word + '?';
            } else {
                return word + '!';
            }
        }
        return word;
    });
}

    function findWorstWordByDifficulty(results, difficulty) {
        const filteredResults = difficulty === 'all' ? results : results.filter(r => r.difficulty === difficulty);

        const wordErrorRates = {};
        let totalAttempts = {};

        filteredResults.forEach(result => {
            if (result.wordErrors) {
                Object.entries(result.wordErrors).forEach(([word, data]) => {
                    if (!wordErrorRates[word]) {
                        wordErrorRates[word] = 0;
                        totalAttempts[word] = 0;
                    }
                    wordErrorRates[word] += data.errors;
                    totalAttempts[word] += data.total;
                });
            }
        });

        let worstWord = '';
        let highestErrorRate = 0;

        for (const [word, errors] of Object.entries(wordErrorRates)) {
            if (totalAttempts[word] > 0) {
                const errorRate = errors / totalAttempts[word];
                if (errorRate > highestErrorRate) {
                    highestErrorRate = errorRate;
                    worstWord = word;
                }
            }
        }

        return { word: worstWord || 'N/A', errorRate: highestErrorRate };
    }

    function startAfkTimer() {
        clearInterval(afkInterval);
        afkInterval = setInterval(checkAfk, 1000); // Check every second
    }


    function cancelSession(message = '') {
    clearInterval(timerInterval);
    clearInterval(afkInterval);
    clearTimeout(afkTimer);
    testActive = false;
    timerStarted = false;
    isTyping = false;
    input.disabled = true;

    // Reset timer and display
    timer = selectedTime;
    updateTimer();
    updateProgressBar(timer);
    resetUIAfterTest();

    // Reset all test-related variables
    currentWordIndex = 0;
    correctWords = 0;
    totalWords = 0;
    correctKeystrokes = 0;
    incorrectKeystrokes = 0;
    totalKeystrokes = 0;
    currentWordKeystrokes = 0;
    currentWordCorrectKeystrokes = 0;
    wordErrors = {};

    testActive = false;
    document.querySelector('.slider-container').classList.remove('test-active');

    // Get references to elements
    const buttonGroup = document.querySelector('.button-group');
    const instructions = document.getElementById('test-instructions');

    // Show buttons and hide instructions
    if (instructions) {
        instructions.classList.remove('active');
    }
    if (buttonGroup) {
        setTimeout(() => {
            buttonGroup.classList.remove('hidden');
        }, 300); // Delay to allow instructions to hide first
    }

    typingArea.innerHTML = 'Select a difficulty to begin.';
    document.body.classList.remove('custom-test-active');

    // Reset UI to neutral state
    resetAllColors();
    resetHeatmap();
    document.documentElement.style.removeProperty('--highlight-color');
    clearBorders();

    // Reset variables
    currentDifficulty = null;
    document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('selected'));
    startButton.style.backgroundColor = '#dddddd';
    startButton.style.color = '#666666';
    startButton.textContent = 'Start Test';
    startButton.disabled = true;
    startButton.onclick = checkDifficulty;

    // Reset average word time variables
    wordStartTime = null;
    totalWordTime = 0;
    wordCount = 0;

    // Clear the update interval if it exists
    if (typeof updateInterval !== 'undefined') {
        clearInterval(updateInterval);
    }

    // Reset the display
    document.getElementById('avg-word-time').textContent = 'Avg. Word Time: 0.0s';
    document.body.classList.remove('test-active');

    // Reset the keyboard border
    resetKeyboardBorder();

    // Re-enable UI elements
    enableUIElements();

    updateDifficultySelector();

    resetSlider();

    // Reset the visualizer waves
    if (visualizer) {
        visualizer.resetWaves();
        visualizer.updateColor('#34495e');  // Reset to default color
    }

    if (message) {
        alert(message);
    }
}


function getDifficultyColor(difficulty) {
    switch (difficulty) {
        case 'beginner':
            return '#2ecc71';  // Green
        case 'intermediate':
            return '#3498db';  // Blue
        case 'advanced':
            return '#9b59b6';  // Purple
        default:
            return '#34495e';  // Dark blue (for custom or unknown difficulties)
    }
}

function resetSlider() {
    var sliderHandle = document.querySelector('.slider-handle');
    var sliderOptions = document.querySelectorAll('.slider-option');
    
    // Reset slider handle position and class
    if (sliderHandle) {
        sliderHandle.style.left = '0%'; // Reset to initial position
        sliderHandle.className = 'slider-handle beginner'; // Reset class to initial state
    }

    // Reset the slider options' text color
    sliderOptions.forEach(option => {
        option.classList.remove('selected'); // Remove selected class from all options
    });
    if (sliderOptions[0]) {
        sliderOptions[0].classList.add('selected'); // Add selected class to the first option (Beginner)
    }
}



function updateDifficultySelector(difficulty) {
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    
    sliderOptions.forEach(option => option.classList.remove('active'));
    
    let leftPosition;
    let selectedDifficulty;
    
    if (difficulty) {
        switch(difficulty) {
            case 'beginner':
                leftPosition = '0%';
                sliderOptions[0].classList.add('active');
                selectedDifficulty = 'beginner';
                break;
            case 'intermediate':
                leftPosition = '33.33%';
                sliderOptions[1].classList.add('active');
                selectedDifficulty = 'intermediate';
                break;
            case 'advanced':
                leftPosition = '66.66%';
                sliderOptions[2].classList.add('active');
                selectedDifficulty = 'advanced';
                break;
        }
    } else {
        // Determine the current difficulty based on the active option
        const activeOption = Array.from(sliderOptions).find(option => option.classList.contains('active'));
        if (activeOption) {
            selectedDifficulty = activeOption.textContent.toLowerCase();
            leftPosition = activeOption.style.left;
        } else {
            // If no option is active, don't change anything
            return;
        }
    }
    
    sliderHandle.style.left = leftPosition;
    return selectedDifficulty;

}

function resetAllColors() {
    // Reset start button color
    startButton.style.backgroundColor = '#dddddd';
    startButton.style.color = '#666666';

    // Reset progress bar color
    const progressBar = document.getElementById('timer-progress-bar');
    if (progressBar) {
        progressBar.style.backgroundColor = '#dddddd';
    }

    // Reset input border color
    const input = document.getElementById('input');
    input.style.borderColor = '#bfbfbf';

    // Reset cursor color
    input.style.setProperty('--cursor-color', '#666666');

    // Reset highlight color
    document.documentElement.style.setProperty('--highlight-color', '#dddddd');

    // Reset key border colors
    updateKeyBorderColors('transparent');

    // Reset difficulty slider
    const sliderHandle = document.querySelector('.slider-handle');
    if (sliderHandle) {
        sliderHandle.style.left = '0%';
        sliderHandle.className = 'slider-handle';
        sliderHandle.style.backgroundColor = '#bcbcbc';
    }

    // Remove all difficulty-specific borders
    const elementsToReset = [
        document.getElementById('typing-area'),
        document.getElementById('input'),
        document.getElementById('time-left'),
        document.getElementById('wpm-box'),
        document.getElementById('accuracy-box')
    ];
    
    elementsToReset.forEach(element => {
        if (element) {
            element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced');
        }
    });
}

    function clearBorders() {
        const elementsToUpdate = [
            document.getElementById('typing-area'),
            document.getElementById('input'),
            document.getElementById('time-left'),
            document.getElementById('wpm-box'),
            document.getElementById('accuracy-box')
        ];
        
        elementsToUpdate.forEach(element => {
            if (element) {
                element.classList.remove('border-beginner', 'border-intermediate', 'border-advanced');
            }
        });
    }

    function getDifficultyColor(difficulty) {
        switch (difficulty) {
            case 'beginner':
                return getComputedStyle(document.documentElement).getPropertyValue('--beginner-color').trim();
            case 'intermediate':
                return getComputedStyle(document.documentElement).getPropertyValue('--intermediate-color').trim();
            case 'advanced':
                return getComputedStyle(document.documentElement).getPropertyValue('--advanced-color').trim();
            default:
                return '#666666';
        }
    }

    function setLocalStorage(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    }

    function getLocalStorage(key) {
        const value = localStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    }

    function updateSliderColor(difficulty) {
    const slider = document.querySelector('#difficultySlider .slider-handle');
    if (slider) {
        // Remove all difficulty classes first
        slider.classList.remove('beginner', 'intermediate', 'advanced', 'initial');
        // Add the new difficulty class
        slider.classList.add(difficulty);
    }
}

    function formatAverageText(value, id, difficulty, timeRange) {
        const isWpm = id === 'avg-wpm';
        const key = `${difficulty}_${timeRange}`;

        console.log('formatAverageText called with:', { value, id, difficulty, timeRange });

        if (!lastKnownValues[id][key]) {
            lastKnownValues[id][key] = value;
            console.log('No previous value, setting and returning:', value);
            return `${value}${isWpm ? ' WPM' : '%'}`;
        }

        const prevValue = lastKnownValues[id][key];
        let arrow = '';
        let color = 'gray';

        if (timeRange === 'today') {
            // For 'today', compare with the overall average
            const overallAvg = calculateOverallAverage(id);
            if (value > overallAvg) {
                arrow = '‚ñ≤';
                color = 'green';
            } else if (value < overallAvg) {
                arrow = '‚ñº';
                color = 'red';
            }
        } else {
            // For other time ranges, compare with the previous value
            if (value > prevValue) {
                arrow = '‚ñ≤';
                color = 'green';
            } else if (value < prevValue) {
                arrow = '‚ñº';
                color = 'red';
            }
        }

        lastKnownValues[id][key] = value;

        console.log('Returning formatted text with arrow:', { value, prevValue, arrow, color });
        return `<span class="arrow" style="color: ${color};">${arrow}</span> ${value}${isWpm ? ' WPM' : '%'}`;
    }

    function calculateOverallAverage(id) {
        const results = getResults();
        if (results.length === 0) return 0;

        const sum = results.reduce((acc, result) => acc + (id === 'avg-wpm' ? result.wpm : result.accuracy), 0);
        return Math.round(sum / results.length);
    }

    function getDifficultyName(difficulty) {
    switch (difficulty) {
        case 'beginner':
            return 'Beginner';
        case 'intermediate':
            return 'Intermediate';
        case 'advanced':
            return 'Advanced';
        default:
            return 'Custom';
    }
}

    window.updateTextSize = function(size, index) {
        const typingArea = document.getElementById('typing-area');
        typingArea.style.fontSize = `${size}px`;
        
        const sliderHandle = document.querySelector('.text-size-slider-handle');
        if (sliderHandle) {
            sliderHandle.style.transform = `translateY(${index * 40}px)`;
        }

        const options = document.querySelectorAll('.text-size-slider-option');
        options.forEach((option, i) => {
            option.classList.toggle('selected', i === index);
        });

        const selectedSizeSpan = document.querySelector('.selected-size');
        if (selectedSizeSpan) {
            selectedSizeSpan.textContent = `(${getSizeText(size)})`;
        }

        localStorage.setItem('preferredFontSize', size);
    }

    function aggregateDataByMonth(data, timeRange) {
    const monthsToShow = timeRange === '180' ? 6 : 12;
    const now = new Date();
    const monthAgo = new Date(now.getFullYear(), now.getMonth() - monthsToShow + 1, 1);
    
    const aggregated = {};
    data.forEach(entry => {
        const date = new Date(entry.date);
        if (date >= monthAgo) {
            const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
            if (!aggregated[monthYear]) {
                aggregated[monthYear] = { sum: 0, count: 0, highestWpm: 0, sessions: 0, durations: [] };
            }
            aggregated[monthYear].sum += entry.wpm;
            aggregated[monthYear].count++;
            aggregated[monthYear].highestWpm = Math.max(aggregated[monthYear].highestWpm, entry.wpm);
            aggregated[monthYear].sessions++;
            aggregated[monthYear].durations.push(entry.duration || 60);
        }
    });

    return Object.entries(aggregated)
        .map(([monthYear, values]) => ({
            label: monthYear,
            date: new Date(monthYear),
            wpm: Math.round(values.sum / values.count),
            highestWpm: values.highestWpm,
            sessions: values.sessions,
            durations: values.durations
        }))
        .sort((a, b) => a.date - b.date);
}

function updateDifficulty(position, difficulty) {
    currentDifficulty = difficulty;
    const mainSliderHandle = document.querySelector('#difficultySlider .slider-handle');
    mainSliderHandle.style.left = `${position}%`;
    mainSliderHandle.className = `slider-handle ${difficulty}`;
    const difficultyColor = getDifficultyColor(difficulty);
    mainSliderHandle.style.backgroundColor = difficultyColor;

    const mainSliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    mainSliderOptions.forEach(option => {
        if (option.textContent.toLowerCase() === difficulty) {
            option.style.color = 'white';
            option.classList.add('selected');
        } else {
            option.style.color = '';
            option.classList.remove('selected');
        }
    });

    setDifficulty(difficulty);
}

function updateVisualizerOpacity(opacity) {
    const visualizer = document.getElementById('waveVisualizer');
    const opacityValue = document.getElementById('opacityValue');
    
    if (visualizer) {
        visualizer.style.opacity = opacity / 100;
    }
    
    if (opacityValue) {
        opacityValue.textContent = `${opacity}%`;
    }
}

    function getSizeText(size) {
                switch(size) {
                    case '18': return 'SM';
                    case '24': return 'MD';
                    case '30': return 'LG';
                    case '36': return 'XL';
                    default: return 'MD';
                }
            }

            sliderContainer.addEventListener('click', (e) => {
    if (testActive) return; // Ignore clicks when test is active

    const rect = sliderContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percentage = (x / rect.width) * 100;
    let position, difficulty, index;

    if (percentage < 33.33) {
        position = 0;
        difficulty = 'beginner';
        index = 0;
    } else if (percentage < 66.66) {
        position = 33.33;
        difficulty = 'intermediate';
        index = 1;
    } else {
        position = 66.66;
        difficulty = 'advanced';
        index = 2;
    }

    sliderHandle.style.left = `${position}%`;
    sliderHandle.className = `slider-handle ${difficulty}`;

    // Update text color for all options
    const sliderOptions = sliderContainer.querySelectorAll('.slider-option');
    sliderOptions.forEach((option, i) => {
        if (i === index) {
            option.style.color = 'white';
            option.classList.add('selected');
        } else {
            option.style.color = '';
            option.classList.remove('selected');
        }
    });
    // Remove glow effect
    difficultySlider.classList.remove('difficulty-glow');


    setDifficulty(difficulty);
    currentDifficulty = difficulty;
});

    window.onclick = function(event) {
        if (event.target.classList.contains('modal')) {
            closeModal(event.target.id);
        }
    }

    if (window.location.protocol === "http:" || window.location.protocol === "https:") {
        var script = document.createElement('script');
        script.src = "https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015";
        script.defer = true;
        script.integrity = "sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==";
        script.setAttribute('data-cf-beacon', '{"rayId":"89d03d9c7ca151f1","version":"2024.4.1","token":"5070e21320304a1ba2b0a42ce9682840"}');
        script.crossOrigin = "anonymous";
        document.head.appendChild(script);
    }

    if (window.location.protocol === "file:") {
        navigator.sendBeacon = function() {
            console.warn("sendBeacon is disabled for local file protocol.");
            return false;
        };
    }
    
    document.getElementById('progress-problematic-words-list').innerHTML = '';
    
    window.onload = function () {
        console.log('Window loaded');
        const input = document.getElementById('input');
    input.addEventListener('input', updateCursorPosition);
    input.addEventListener('click', updateCursorPosition);
    document.addEventListener('DOMContentLoaded', updateTypingAreaText);
    document.getElementById('hide-ui-toggle').checked = localStorage.getItem('hideUI') === 'true';
    window.addEventListener('resize', updateTestInstructionsPosition);
    window.addEventListener('load', updateTooltips);
    document.getElementById('black-white-toggle').addEventListener('change', toggleBlackWhiteMode);
    waveVisualizerUnlocked = localStorage.getItem('waveVisualizerUnlocked') === 'true';
    document.getElementById('waveVisualizer').style.display = waveVisualizerUnlocked ? 'block' : 'none';
    document.querySelector('.visualizer-opacity-slider').style.display = waveVisualizerUnlocked ? 'flex' : 'none';

    visualizer = new WaveVisualizer();
    visualizer.animate();
    initializeKeyboard();
    updateTooltips();

    const savedHideUI = localStorage.getItem('hideUI') === 'true';
    document.getElementById('hide-ui-toggle').checked = savedHideUI;
    document.body.classList.toggle('hide-ui', savedHideUI);
    
    // Call this function when the page loads
    loadWordErrorTracker();
    
            document.getElementById('support-icon').addEventListener('click', function() {
        document.getElementById('supportModal').style.display = 'block';
        });

        document.querySelector('#supportModal .support-close-button').addEventListener('click', function() {
        document.getElementById('supportModal').style.display = 'none';
        });

        window.addEventListener('click', function(event) {
        if (event.target == document.getElementById('supportModal')) {
            document.getElementById('supportModal').style.display = 'none';
        }
        });

        document.addEventListener('DOMContentLoaded', () => {
            changeKeyboardLayout(); // Set the initial layout
            heatmapEnabled = localStorage.getItem('heatmapEnabled') === 'true';
    document.getElementById('keyboard-heatmap-toggle').checked = heatmapEnabled;
    toggleHeatmap();
        });

        // Add glow effect to difficulty selector
    const difficultySlider = document.getElementById('difficultySlider');
    difficultySlider.classList.add('difficulty-glow');

    

    document.addEventListener('DOMContentLoaded', () => {
    const savedBlackWhitePreference = localStorage.getItem('blackWhiteMode');
    if (savedBlackWhitePreference !== null) {
        const isBlackWhite = savedBlackWhitePreference === 'true';
        document.getElementById('black-white-toggle').checked = isBlackWhite;
        document.body.classList.toggle('black-white-mode', isBlackWhite);
    }
});

document.getElementById('generate-random-words').addEventListener('click', function() {
    const randomWords = generateRandomWords();
    document.getElementById('custom-text-input').value = randomWords;
});

document.addEventListener('DOMContentLoaded', function() {
    const tooltipTrigger = document.querySelector('.tooltip-trigger');
    let tooltipVisible = false;
 
    tooltipTrigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipVisible = !tooltipVisible;
        if (tooltipVisible) {
            this.style.setProperty('--tooltip-visibility', 'visible');
            this.style.setProperty('--tooltip-opacity', '1');
        } else {
            this.style.setProperty('--tooltip-visibility', 'hidden');
            this.style.setProperty('--tooltip-opacity', '0');
        }
    });
});

document.addEventListener('DOMContentLoaded', function() {
    const opacitySlider = document.getElementById('opacitySlider');
    const opacityValue = document.getElementById('opacityValue');
    const visualizer = document.getElementById('waveVisualizer');
    const opacitySliderContainer = document.querySelector('.visualizer-opacity-slider');
 
    // Check if the visualizer is unlocked
    const visualizerUnlocked = localStorage.getItem('waveVisualizerUnlocked') === 'true';
 
    if (visualizerUnlocked) {
        // Load the saved opacity or use default
        const savedOpacity = localStorage.getItem('visualizerOpacity') || 50;
        opacitySlider.value = savedOpacity;
        updateVisualizerOpacity(savedOpacity);
 
        visualizer.style.display = 'block';
        opacitySliderContainer.style.display = 'flex';
    } else {
        visualizer.style.display = 'none';
        opacitySliderContainer.style.display = 'none';
    }
 
    opacitySlider.addEventListener('input', function() {
        const opacity = this.value;
        updateVisualizerOpacity(opacity);
       
        // Save the current opacity to localStorage
        localStorage.setItem('visualizerOpacity', opacity);
    });
 
    function updateVisualizerOpacity(opacity) {
        const normalizedOpacity = opacity / 100;
        visualizer.style.opacity = normalizedOpacity;
        opacityValue.textContent = `${opacity}%`;
    }
});

document.getElementById('custom-add-problematic-words').addEventListener('click', function() {
    const customTextInput = document.getElementById('custom-text-input');
    const problematicWords = getTopProblematicWords(10, true); // Get words only
    console.log('Problematic words to add:', problematicWords);
    console.log('Type of problematicWords:', typeof problematicWords);
    console.log('Is problematicWords an array?', Array.isArray(problematicWords));

    if (!Array.isArray(problematicWords)) {
        console.error('problematicWords is not an array. Actual value:', problematicWords);
        return; // Exit the function if problematicWords is not an array
    }

    const problematicWordsText = problematicWords
        .filter(word => {
            console.log('Processing word:', word, 'Type:', typeof word);
            return typeof word === 'string';
        })
        .join(' ');

    console.log('Text to add:', problematicWordsText);

    customTextInput.value += (customTextInput.value ? ' ' : '') + problematicWordsText;
    console.log('Input value after setting:', customTextInput.value);

    console.log('Final input value:', customTextInput.value);
});
    
document.addEventListener('DOMContentLoaded', () => {
    visualizer = new WaveVisualizer();
    visualizer.animate();
});

    document.addEventListener('DOMContentLoaded', function() {
    const sliderContainer = document.getElementById('difficultySlider');
    const sliderHandle = sliderContainer.querySelector('.slider-handle');
    document.addEventListener('DOMContentLoaded', function() {
    // Add the keydown event listener here
    const sliderContainer = document.getElementById('difficultySlider');
    sliderContainer.addEventListener('click', handleSliderClick);

    

    sliderContainer.addEventListener('click', (e) => {
        if (testActive || isProgressModalOpen) return;

        const rect = sliderContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        let position;

        if (percentage < 33.33) {
            position = 0;
        } else if (percentage < 66.66) {
            position = 33.33;
        } else {
            position = 66.66;
        }

        const difficulty = updateDifficulty(position);
        if (difficulty) {
            setDifficulty(difficulty);
            updateDifficultySelector(difficulty);
            difficultySelected = true;
            
            const customTextBtn = document.getElementById('custom-text-btn');
            if (customTextBtn) {
                customTextBtn.classList.remove('selected');
            }
        }
    });

    
});
});

   


        
       
    // Check if the elements exist before adding event listeners
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    
    // Handle heatmap visibility
    const keyboardContainer = document.getElementById('keyboard-container');
    const heatmapToggle = document.getElementById('keyboard-heatmap-toggle');
    if (localStorage.getItem('heatmapEnabled') === 'true') {
        if (keyboardContainer) {
            keyboardContainer.style.display = 'block';
        }
        if (heatmapToggle) {
            heatmapToggle.checked = true;
        }
    } else {
        if (keyboardContainer) {
            keyboardContainer.style.display = 'none';
        }
        if (heatmapToggle) {
            heatmapToggle.checked = false;
        }
    }

        if (darkModeToggle) {
            darkModeToggle.addEventListener('change', toggleDarkMode);
        }

        if (heatmapToggle) {
            heatmapToggle.addEventListener('change', toggleHeatmap);
        }

    // Initialize other elements and settings
    loadSavedFontSize();
    initializeLastKnownValues();
    initialLoad();
    addButtonEventListeners();
    updateButtonColors();
    initializeKeyboard();
    updateHeatmap();
    initializePunctuationPreference();
    

    // Handle dark mode
    if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        if (darkModeToggle) darkModeToggle.checked = true;
        updateButtonColors();
    }

    // Handle heatmap visibility
    const heatmapContainer = document.getElementById('keyboard-heatmap');
    if (localStorage.getItem('heatmapEnabled') === 'true') {
        if (heatmapContainer) {
            heatmapContainer.style.display = 'block';
            if (heatmapToggle) heatmapToggle.checked = true;
        }
    } else {
        if (heatmapContainer) {
            heatmapContainer.style.display = 'none';
        }
    }

    filterByTimeRange();

    // Add event listeners to filter buttons
    const timeRangeSelector = document.getElementById('time-range-selector');


    if (timeRangeSelector) timeRangeSelector.addEventListener('change', filterByTimeRange);
};

function toggleHeatmap() {
    const heatmapToggle = document.getElementById('keyboard-heatmap-toggle');
    const keyboardContainer = document.getElementById('keyboard-container');

    heatmapEnabled = heatmapToggle.checked;
    
    if (heatmapEnabled) {
        keyboardContainer.style.display = 'block';
        updateKeyboardColors();
    } else {
        keyboardContainer.style.display = 'none';
    }

    localStorage.setItem('heatmapEnabled', heatmapEnabled.toString());

    updateTestInstructionsPosition();
}

function initializePunctuationPreference() {
    const checkbox = document.getElementById('add-punctuation-checkbox');
    const savedPreference = localStorage.getItem('addPunctuationPreference');
    
    if (savedPreference !== null) {
        checkbox.checked = savedPreference === 'true';
    }

    checkbox.addEventListener('change', function() {
        localStorage.setItem('addPunctuationPreference', this.checked);
    });
}




function handleDarkModeToggle() {
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    updateHeatmap(); // Update heatmap colors when switching modes
}

function ensureDifficultySelected() {
    if (!currentDifficulty || currentDifficulty === 'custom') {
        currentDifficulty = lastUsedDifficulty || 'beginner';
        setDifficulty(currentDifficulty);
        updateDifficultyUI(currentDifficulty);
    }
}

function resetHeatmap() {
    keyPressCount = {};
    document.querySelectorAll('.key').forEach(key => {
        key.style.backgroundColor = 'transparent';
    });
}

function getHeatColor(intensity) {
    //light red to dark red
    const r = Math.round(intensity * 255);
    return `rgba(255, 0, 0, ${intensity})`;
}

document.addEventListener('keydown', handleKeyboardControls);

function handleKeyboardControls(event) {
    if (isAnyModalOpen()) {
        return;
    }

    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const ctrlKey = isMac ? event.metaKey : event.ctrlKey;

    if (ctrlKey) {
        switch (event.key) {
            case '0':
                event.preventDefault();
                toggleDarkMode();
                break;
            case '1':
                event.preventDefault();
                toggleKeyboard();
                break;
            case '2':
                event.preventDefault();
                toggleBlackWhiteMode();
                break;
            case '3':
                event.preventDefault();
                toggleUIVisibility();
                break;
        }
    } else {
        switch (event.key) {
            case 'Escape':
                if (testActive) cancelSession();
                break;
            case 'Enter':
                if (!isAnyModalOpen()) {
                    if (!currentDifficulty || currentDifficulty === 'custom') {
                        ensureDifficultySelected();
                    }
                    handleStartReset();
                }
                break;
            case 'ArrowRight':
            case 'ArrowLeft':
                if (!testActive && !isProgressModalOpen) {
                    event.preventDefault();
                    updateDifficultyWithArrows(event.key);
                    if (currentDifficulty) {
                        setDifficulty(currentDifficulty);
                    }
                }
                break;
            case 'ArrowUp':
            case 'ArrowDown':
                if (!testActive) {
                    event.preventDefault();
                    changeTextSize(event.key === 'ArrowUp' ? 'increase' : 'decrease');
                }
                break;
        }
    }
}

function updateTooltips() {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modifier = isMac ? '‚åò' : 'Ctrl';

    document.getElementById('keyboard-heatmap-toggle').parentElement.title = `${modifier}+1: Toggle keyboard visibility`;
    document.getElementById('black-white-toggle').parentElement.title = `${modifier}+2: Toggle black & white mode`;
    document.getElementById('hide-ui-toggle').parentElement.title = `${modifier}+3: Toggle UI visibility`;
    document.getElementById('dark-mode-toggle').parentElement.title = `${modifier}+0: Toggle dark/light mode`;
}

function updateDifficultyWithArrows(key) {
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    let currentPosition = parseFloat(sliderHandle.style.left) || 0;
    let newPosition;

    if (key === 'ArrowRight') {
        newPosition = Math.min(currentPosition + 33.33, 66.66);
    } else if (key === 'ArrowLeft') {
        newPosition = Math.max(currentPosition - 33.33, 0);
    } else {
        return;
    }

    let difficulty;
    if (newPosition === 0) {
        difficulty = 'beginner';
    } else if (newPosition === 33.33) {
        difficulty = 'intermediate';
    } else {
        difficulty = 'advanced';
    }

    updateDifficulty(newPosition, difficulty);
    removeDifficultyGlow();
    
    // Ensure the currentDifficulty is set
    currentDifficulty = difficulty;
    
    // Update the UI to reflect the new difficulty
    updateDifficultyUI(difficulty);
}

// Add this new function to update the UI
function updateDifficultyUI(difficulty) {
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
    
    let position;
    switch(difficulty) {
        case 'beginner': position = '0%'; break;
        case 'intermediate': position = '33.33%'; break;
        case 'advanced': position = '66.66%'; break;
        default: position = '0%';
    }

    sliderHandle.style.left = position;
    sliderHandle.className = `slider-handle ${difficulty}`;
    
    sliderOptions.forEach(option => {
        option.classList.toggle('selected', option.textContent.toLowerCase() === difficulty);
    });
    
}

function cycleDifficulty(direction) {
    const difficulties = ['beginner', 'intermediate', 'advanced'];
    let currentIndex = difficulties.indexOf(currentDifficulty);
    if (currentIndex === -1) currentIndex = 0;

    if (direction === 'next') {
        currentIndex = (currentIndex + 1) % difficulties.length;
    } else {
        currentIndex = (currentIndex - 1 + difficulties.length) % difficulties.length;
    }

    const newDifficulty = difficulties[currentIndex];
    
    // Update slider position and color
    const sliderHandle = document.querySelector('#difficultySlider .slider-handle');
    if (sliderHandle) {
        let position, color;
        switch (newDifficulty) {
            case 'beginner':
                position = '0%';
                color = '#4CAF50'; // Green color for beginner
                break;
            case 'intermediate':
                position = '33.33%';
                color = '#FFA500'; // Orange color for intermediate
                break;
            case 'advanced':
                position = '66.66%';
                color = '#FF0000'; // Red color for advanced
                break;
        }
        
        // Apply the new position, class, and color
        sliderHandle.style.left = position;
        sliderHandle.className = `slider-handle ${newDifficulty}`;
        sliderHandle.style.backgroundColor = color;
        
        // Update text color for all options
        const sliderOptions = document.querySelectorAll('#difficultySlider .slider-option');
        sliderOptions.forEach((option, index) => {
            if (index === currentIndex) {
                option.style.color = 'white';
                option.classList.add('selected');
            } else {
                option.style.color = '';
                option.classList.remove('selected');
            }
        });

        // Wait for the transition to complete before setting the difficulty
        setTimeout(() => {
            setDifficulty(newDifficulty);
        }, 300); // This should match the transition duration in CSS
    }
}

function changeTextSize(direction) {
    const sizes = [18, 24, 30, 36];
    const typingArea = document.getElementById('typing-area');
    const currentSize = parseInt(getComputedStyle(typingArea).fontSize);
    let currentIndex = sizes.indexOf(currentSize);
    if (currentIndex === -1) currentIndex = 1; // Default to medium if not found

    if (direction === 'increase') {
        currentIndex = Math.min(currentIndex + 1, sizes.length - 1);
    } else {
        currentIndex = Math.max(currentIndex - 1, 0);
    }
    window.updateTextSize(sizes[currentIndex].toString(), currentIndex);
}

function toggleKeyboard() {
    const keyboardContainer = document.getElementById('keyboard-container');
    const keyboardToggle = document.getElementById('keyboard-heatmap-toggle');
    keyboardToggle.checked = !keyboardToggle.checked;
    toggleHeatmap();
}



document.addEventListener('DOMContentLoaded', function() {
    const tooltipTrigger = document.querySelector('.tooltip-trigger');
    let tooltipVisible = false;

    tooltipTrigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipVisible = !tooltipVisible;
        if (tooltipVisible) {
            this.style.setProperty('--tooltip-visibility', 'visible');
            this.style.setProperty('--tooltip-opacity', '1');
        } else {
            this.style.setProperty('--tooltip-visibility', 'hidden');
            this.style.setProperty('--tooltip-opacity', '0');
        }
    });
});


document.getElementById('opacitySlider').addEventListener('input', function() {
    const opacity = this.value / 100;
    document.getElementById('waveVisualizer').style.opacity = opacity;
});


// Apply stored preferences on page load
document.addEventListener('DOMContentLoaded', function () {
            // Initialize theme based on saved preference
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const currentTheme = localStorage.getItem('theme') || 'light';

            if (currentTheme === 'dark') {
                document.body.classList.add('dark-mode');
                darkModeToggle.checked = true;
            } else {
                document.body.classList.add('light-mode');
            }

            // Add event listener to toggle switch
            darkModeToggle.addEventListener('change', function () {
                if (darkModeToggle.checked) {
                    document.body.classList.remove('light-mode');
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.body.classList.remove('dark-mode');
                    document.body.classList.add('light-mode');
                    localStorage.setItem('theme', 'light');
                }
            });
        });


        document.addEventListener('DOMContentLoaded', function() {
    const inputField = document.getElementById('input'); // Assuming 'input' is your input field's ID

    inputField.addEventListener('input', function() {
        if (!document.body.classList.contains('test-active')) {
            document.body.classList.add('test-active');
            
            startTest()
        }
    });
});

        document.addEventListener('DOMContentLoaded', () => {
            const heatmapEnabled = localStorage.getItem('heatmapEnabled') === 'true';
            document.getElementById('keyboard-heatmap-toggle').checked = heatmapEnabled;
            toggleHeatmap(); // Ensure the heatmap state is applied
            const preferredLayout = localStorage.getItem('preferredLayout') || 'qwerty';
            document.getElementById('keyboard-layout-selector').value = preferredLayout;
            keyboardLayout = preferredLayout;
            initializeKeyboard();
        });

        // Save user preference when layout is changed
        document.getElementById('keyboard-layout-selector').addEventListener('change', () => {
            keyboardLayout = document.getElementById('keyboard-layout-selector').value;
            localStorage.setItem('preferredLayout', keyboardLayout);
            if (document.getElementById('keyboard-heatmap-toggle').checked) {
                initializeKeyboard();
            }
        });

        

        document.addEventListener('DOMContentLoaded', function() {
            const textSizeContainer = document.querySelector('.text-size-selector-container');
            const textSizeSlider = document.getElementById('textSizeSlider');
            const sliderHandle = textSizeSlider.querySelector('.text-size-slider-handle');
            const typingArea = document.getElementById('typing-area');
            const options = textSizeSlider.querySelectorAll('.text-size-slider-option');
            const selectedSizeSpan = document.querySelector('.selected-size');

            let isOpen = false;

            textSizeContainer.addEventListener('click', function(e) {
                if (!isOpen) {
                    openTextSizeSelector();
                } else if (e.target.classList.contains('text-size-slider-option')) {
                    const size = e.target.dataset.size;
                    const index = Array.from(options).indexOf(e.target);
                    updateTextSize(size, index);
                    closeTextSizeSelector();
                }
            });

            function openTextSizeSelector() {
                textSizeContainer.classList.add('open');
                isOpen = true;
            }

            function closeTextSizeSelector() {
                textSizeContainer.classList.remove('open');
                isOpen = false;
            }

            

            

            function updateSelectedSizeText(sizeText) {
                selectedSizeSpan.textContent = `(${sizeText})`;
            }

            // Load saved font size
            const savedSize = localStorage.getItem('preferredFontSize') || '24';
            const savedIndex = Array.from(options).findIndex(option => option.dataset.size === savedSize);
            if (savedIndex !== -1) {
                updateTextSize(savedSize, savedIndex);
            } else {
                updateTextSize('24', 1); // Default to medium if not found
            }

            // Set initial selected state
            const initialIndex = savedIndex !== -1 ? savedIndex : 1;
            options[initialIndex].classList.add('selected');
            updateSelectedSizeText(getSizeText(options[initialIndex].dataset.size));
        });

        

        function animateValue(obj, start, end, duration, isPercentage = false) {
            console.log('Animating value:', { start, end, duration, isPercentage });
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                let value = Math.floor(progress * (end - start) + start);
                obj.textContent = isPercentage ? value + '%' : value;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        }

        function disableUIElements() {
            document.getElementById('difficultySlider').style.pointerEvents = 'none';
            document.querySelector('.text-size-selector-container').style.pointerEvents = 'none';
            document.getElementById('custom-text-btn').disabled = true;
            document.getElementById('time-selector').style.pointerEvents = 'none';
            document.getElementById('view-progress-button').disabled = true;
        }

        function enableUIElements() {
            document.getElementById('difficultySlider').style.pointerEvents = 'auto';
            document.querySelector('.text-size-selector-container').style.pointerEvents = 'auto';
            document.getElementById('custom-text-btn').disabled = false;
            document.getElementById('time-selector').style.pointerEvents = 'auto';
            document.getElementById('view-progress-button').disabled = false;
        }

        function animateAccuracyBox(overallAccuracy, wordAccuracy, keystrokeAccuracy) {
            const accuracyBox = document.getElementById('accuracy-box');
            const accuracyElement = document.getElementById('accuracy');
            const wordAccuracyElement = document.getElementById('word-accuracy');
            const keyAccuracyElement = document.getElementById('key-accuracy');

            let startOverall = parseInt(accuracyElement.textContent) || 100;
            let startWord = parseInt(wordAccuracyElement.textContent.split(':')[1]) || 100;
            let startKey = parseInt(keyAccuracyElement.textContent.split(':')[1]) || 100;

            const duration = 500; // milliseconds
            let startTimestamp = null;

            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);

                const currentOverall = Math.floor(progress * (overallAccuracy - startOverall) + startOverall);
                const currentWord = Math.floor(progress * (wordAccuracy - startWord) + startWord);
                const currentKey = Math.floor(progress * (keystrokeAccuracy - startKey) + startKey);

                accuracyElement.textContent = `${currentOverall}%`;
                wordAccuracyElement.textContent = `Word: ${currentWord}%`;
                keyAccuracyElement.textContent = `Key: ${currentKey}%`;

                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };

            window.requestAnimationFrame(step);
        }


        






// Event listener for dark mode toggle
document.getElementById('dark-mode-toggle').addEventListener('change', toggleDarkMode);
window.addEventListener('load', initializeKeyboard);
window.addEventListener('load', initializeTimeSelector);
window.addEventListener('load', updatePlatformInstructions);
document.addEventListener('DOMContentLoaded', updateTestInstructionsPosition);
window.addEventListener('load', updatePlatformInstructions);
document.querySelector('.nav-button.prev').addEventListener('click', showPreviousPage);
document.querySelector('.nav-button.next').addEventListener('click', showNextPage);
window.addEventListener('load', adjustModalSize);
window.addEventListener('resize', adjustModalSize);



</script>

<div id="support-icon">
    <span class="icon">‚ù§Ô∏è</span>
    <span class="text">Support</span>
  </div>

    <footer style="text-align: center; margin-top: 20px; font-size: 14px; color: #888;">
        &copy; 2024 All rights reserved.
    </footer>
    
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"8b75918a0fbf7b30","serverTiming":{"name":{"cfL4":true}},"version":"2024.8.0","token":"5070e21320304a1ba2b0a42ce9682840"}' crossorigin="anonymous"></script>
</body>


</html>
